// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_controller_description.proto

#ifndef PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto
#define PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_robot_5fcontroller_5fdescription_2eproto 

namespace protobuf_robot_5fcontroller_5fdescription_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_robot_5fcontroller_5fdescription_2eproto
namespace abb {
namespace robot {
class AddInIndicators;
class AddInIndicatorsDefaultTypeInternal;
extern AddInIndicatorsDefaultTypeInternal _AddInIndicators_default_instance_;
class Arm;
class ArmDefaultTypeInternal;
extern ArmDefaultTypeInternal _Arm_default_instance_;
class Cartesian;
class CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Joint;
class JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class MechanicalUnit;
class MechanicalUnitDefaultTypeInternal;
extern MechanicalUnitDefaultTypeInternal _MechanicalUnit_default_instance_;
class MechanicalUnitGroup;
class MechanicalUnitGroupDefaultTypeInternal;
extern MechanicalUnitGroupDefaultTypeInternal _MechanicalUnitGroup_default_instance_;
class OptionIndicators;
class OptionIndicatorsDefaultTypeInternal;
extern OptionIndicatorsDefaultTypeInternal _OptionIndicators_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RAPIDModule;
class RAPIDModuleDefaultTypeInternal;
extern RAPIDModuleDefaultTypeInternal _RAPIDModule_default_instance_;
class RAPIDTask;
class RAPIDTaskDefaultTypeInternal;
extern RAPIDTaskDefaultTypeInternal _RAPIDTask_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotControllerDescription;
class RobotControllerDescriptionDefaultTypeInternal;
extern RobotControllerDescriptionDefaultTypeInternal _RobotControllerDescription_default_instance_;
class RobotIndicators;
class RobotIndicatorsDefaultTypeInternal;
extern RobotIndicatorsDefaultTypeInternal _RobotIndicators_default_instance_;
class RobotWareVersion;
class RobotWareVersionDefaultTypeInternal;
extern RobotWareVersionDefaultTypeInternal _RobotWareVersion_default_instance_;
class Single;
class SingleDefaultTypeInternal;
extern SingleDefaultTypeInternal _Single_default_instance_;
class StandardizedJoint;
class StandardizedJointDefaultTypeInternal;
extern StandardizedJointDefaultTypeInternal _StandardizedJoint_default_instance_;
class SystemIndicators;
class SystemIndicatorsDefaultTypeInternal;
extern SystemIndicatorsDefaultTypeInternal _SystemIndicators_default_instance_;
class Transmission;
class TransmissionDefaultTypeInternal;
extern TransmissionDefaultTypeInternal _Transmission_default_instance_;
}  // namespace robot
}  // namespace abb
namespace google {
namespace protobuf {
template<> ::abb::robot::AddInIndicators* Arena::CreateMaybeMessage<::abb::robot::AddInIndicators>(Arena*);
template<> ::abb::robot::Arm* Arena::CreateMaybeMessage<::abb::robot::Arm>(Arena*);
template<> ::abb::robot::Cartesian* Arena::CreateMaybeMessage<::abb::robot::Cartesian>(Arena*);
template<> ::abb::robot::Header* Arena::CreateMaybeMessage<::abb::robot::Header>(Arena*);
template<> ::abb::robot::Joint* Arena::CreateMaybeMessage<::abb::robot::Joint>(Arena*);
template<> ::abb::robot::MechanicalUnit* Arena::CreateMaybeMessage<::abb::robot::MechanicalUnit>(Arena*);
template<> ::abb::robot::MechanicalUnitGroup* Arena::CreateMaybeMessage<::abb::robot::MechanicalUnitGroup>(Arena*);
template<> ::abb::robot::OptionIndicators* Arena::CreateMaybeMessage<::abb::robot::OptionIndicators>(Arena*);
template<> ::abb::robot::Pose* Arena::CreateMaybeMessage<::abb::robot::Pose>(Arena*);
template<> ::abb::robot::Quaternion* Arena::CreateMaybeMessage<::abb::robot::Quaternion>(Arena*);
template<> ::abb::robot::RAPIDModule* Arena::CreateMaybeMessage<::abb::robot::RAPIDModule>(Arena*);
template<> ::abb::robot::RAPIDTask* Arena::CreateMaybeMessage<::abb::robot::RAPIDTask>(Arena*);
template<> ::abb::robot::Robot* Arena::CreateMaybeMessage<::abb::robot::Robot>(Arena*);
template<> ::abb::robot::RobotControllerDescription* Arena::CreateMaybeMessage<::abb::robot::RobotControllerDescription>(Arena*);
template<> ::abb::robot::RobotIndicators* Arena::CreateMaybeMessage<::abb::robot::RobotIndicators>(Arena*);
template<> ::abb::robot::RobotWareVersion* Arena::CreateMaybeMessage<::abb::robot::RobotWareVersion>(Arena*);
template<> ::abb::robot::Single* Arena::CreateMaybeMessage<::abb::robot::Single>(Arena*);
template<> ::abb::robot::StandardizedJoint* Arena::CreateMaybeMessage<::abb::robot::StandardizedJoint>(Arena*);
template<> ::abb::robot::SystemIndicators* Arena::CreateMaybeMessage<::abb::robot::SystemIndicators>(Arena*);
template<> ::abb::robot::Transmission* Arena::CreateMaybeMessage<::abb::robot::Transmission>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace abb {
namespace robot {

enum MechanicalUnit_Type {
  MechanicalUnit_Type_UNDEFINED = 0,
  MechanicalUnit_Type_NONE = 1,
  MechanicalUnit_Type_TCP_ROBOT = 2,
  MechanicalUnit_Type_ROBOT = 3,
  MechanicalUnit_Type_SINGLE = 4
};
bool MechanicalUnit_Type_IsValid(int value);
const MechanicalUnit_Type MechanicalUnit_Type_Type_MIN = MechanicalUnit_Type_UNDEFINED;
const MechanicalUnit_Type MechanicalUnit_Type_Type_MAX = MechanicalUnit_Type_SINGLE;
const int MechanicalUnit_Type_Type_ARRAYSIZE = MechanicalUnit_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MechanicalUnit_Type_descriptor();
inline const ::std::string& MechanicalUnit_Type_Name(MechanicalUnit_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MechanicalUnit_Type_descriptor(), value);
}
inline bool MechanicalUnit_Type_Parse(
    const ::std::string& name, MechanicalUnit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MechanicalUnit_Type>(
    MechanicalUnit_Type_descriptor(), name, value);
}
enum MechanicalUnit_Mode {
  MechanicalUnit_Mode_DEACTIVATED = 0,
  MechanicalUnit_Mode_ACTIVATED = 1
};
bool MechanicalUnit_Mode_IsValid(int value);
const MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MIN = MechanicalUnit_Mode_DEACTIVATED;
const MechanicalUnit_Mode MechanicalUnit_Mode_Mode_MAX = MechanicalUnit_Mode_ACTIVATED;
const int MechanicalUnit_Mode_Mode_ARRAYSIZE = MechanicalUnit_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MechanicalUnit_Mode_descriptor();
inline const ::std::string& MechanicalUnit_Mode_Name(MechanicalUnit_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MechanicalUnit_Mode_descriptor(), value);
}
inline bool MechanicalUnit_Mode_Parse(
    const ::std::string& name, MechanicalUnit_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MechanicalUnit_Mode>(
    MechanicalUnit_Mode_descriptor(), name, value);
}
enum RAPIDTask_ExecutionState {
  RAPIDTask_ExecutionState_UNKNOWN = 1,
  RAPIDTask_ExecutionState_READY = 2,
  RAPIDTask_ExecutionState_STOPPED = 3,
  RAPIDTask_ExecutionState_STARTED = 4,
  RAPIDTask_ExecutionState_UNINITIALIZED = 5
};
bool RAPIDTask_ExecutionState_IsValid(int value);
const RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MIN = RAPIDTask_ExecutionState_UNKNOWN;
const RAPIDTask_ExecutionState RAPIDTask_ExecutionState_ExecutionState_MAX = RAPIDTask_ExecutionState_UNINITIALIZED;
const int RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE = RAPIDTask_ExecutionState_ExecutionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RAPIDTask_ExecutionState_descriptor();
inline const ::std::string& RAPIDTask_ExecutionState_Name(RAPIDTask_ExecutionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RAPIDTask_ExecutionState_descriptor(), value);
}
inline bool RAPIDTask_ExecutionState_Parse(
    const ::std::string& name, RAPIDTask_ExecutionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RAPIDTask_ExecutionState>(
    RAPIDTask_ExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string options = 6;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 6;
  const ::std::string& options(int index) const;
  ::std::string* mutable_options(int index);
  void set_options(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_options(int index, ::std::string&& value);
  #endif
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  ::std::string* add_options();
  void add_options(const ::std::string& value);
  #if LANG_CXX11
  void add_options(::std::string&& value);
  #endif
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // optional string ip_address = 1;
  bool has_ip_address() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // optional string system_name = 4;
  bool has_system_name() const;
  void clear_system_name();
  static const int kSystemNameFieldNumber = 4;
  const ::std::string& system_name() const;
  void set_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_system_name(::std::string&& value);
  #endif
  void set_system_name(const char* value);
  void set_system_name(const char* value, size_t size);
  ::std::string* mutable_system_name();
  ::std::string* release_system_name();
  void set_allocated_system_name(::std::string* system_name);

  // optional string system_type = 5;
  bool has_system_type() const;
  void clear_system_type();
  static const int kSystemTypeFieldNumber = 5;
  const ::std::string& system_type() const;
  void set_system_type(const ::std::string& value);
  #if LANG_CXX11
  void set_system_type(::std::string&& value);
  #endif
  void set_system_type(const char* value);
  void set_system_type(const char* value, size_t size);
  ::std::string* mutable_system_type();
  ::std::string* release_system_type();
  void set_allocated_system_type(::std::string* system_type);

  // optional .abb.robot.RobotWareVersion robot_ware_version = 3;
  bool has_robot_ware_version() const;
  void clear_robot_ware_version();
  static const int kRobotWareVersionFieldNumber = 3;
  private:
  const ::abb::robot::RobotWareVersion& _internal_robot_ware_version() const;
  public:
  const ::abb::robot::RobotWareVersion& robot_ware_version() const;
  ::abb::robot::RobotWareVersion* release_robot_ware_version();
  ::abb::robot::RobotWareVersion* mutable_robot_ware_version();
  void set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* robot_ware_version);

  // optional uint32 rws_port_number = 2;
  bool has_rws_port_number() const;
  void clear_rws_port_number();
  static const int kRwsPortNumberFieldNumber = 2;
  ::google::protobuf::uint32 rws_port_number() const;
  void set_rws_port_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:abb.robot.Header)
 private:
  void set_has_ip_address();
  void clear_has_ip_address();
  void set_has_rws_port_number();
  void clear_has_rws_port_number();
  void set_has_robot_ware_version();
  void clear_has_robot_ware_version();
  void set_has_system_name();
  void clear_has_system_name();
  void set_has_system_type();
  void clear_has_system_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::internal::ArenaStringPtr system_name_;
  ::google::protobuf::internal::ArenaStringPtr system_type_;
  ::abb::robot::RobotWareVersion* robot_ware_version_;
  ::google::protobuf::uint32 rws_port_number_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotControllerDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotControllerDescription) */ {
 public:
  RobotControllerDescription();
  virtual ~RobotControllerDescription();

  RobotControllerDescription(const RobotControllerDescription& from);

  inline RobotControllerDescription& operator=(const RobotControllerDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotControllerDescription(RobotControllerDescription&& from) noexcept
    : RobotControllerDescription() {
    *this = ::std::move(from);
  }

  inline RobotControllerDescription& operator=(RobotControllerDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotControllerDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotControllerDescription* internal_default_instance() {
    return reinterpret_cast<const RobotControllerDescription*>(
               &_RobotControllerDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RobotControllerDescription* other);
  friend void swap(RobotControllerDescription& a, RobotControllerDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotControllerDescription* New() const final {
    return CreateMaybeMessage<RobotControllerDescription>(NULL);
  }

  RobotControllerDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotControllerDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotControllerDescription& from);
  void MergeFrom(const RobotControllerDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotControllerDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
  int mechanical_units_groups_size() const;
  void clear_mechanical_units_groups();
  static const int kMechanicalUnitsGroupsFieldNumber = 3;
  ::abb::robot::MechanicalUnitGroup* mutable_mechanical_units_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >*
      mutable_mechanical_units_groups();
  const ::abb::robot::MechanicalUnitGroup& mechanical_units_groups(int index) const;
  ::abb::robot::MechanicalUnitGroup* add_mechanical_units_groups();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >&
      mechanical_units_groups() const;

  // repeated .abb.robot.RAPIDTask rapid_tasks = 4;
  int rapid_tasks_size() const;
  void clear_rapid_tasks();
  static const int kRapidTasksFieldNumber = 4;
  ::abb::robot::RAPIDTask* mutable_rapid_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >*
      mutable_rapid_tasks();
  const ::abb::robot::RAPIDTask& rapid_tasks(int index) const;
  ::abb::robot::RAPIDTask* add_rapid_tasks();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >&
      rapid_tasks() const;

  // optional .abb.robot.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::abb::robot::Header& _internal_header() const;
  public:
  const ::abb::robot::Header& header() const;
  ::abb::robot::Header* release_header();
  ::abb::robot::Header* mutable_header();
  void set_allocated_header(::abb::robot::Header* header);

  // optional .abb.robot.SystemIndicators system_indicators = 2;
  bool has_system_indicators() const;
  void clear_system_indicators();
  static const int kSystemIndicatorsFieldNumber = 2;
  private:
  const ::abb::robot::SystemIndicators& _internal_system_indicators() const;
  public:
  const ::abb::robot::SystemIndicators& system_indicators() const;
  ::abb::robot::SystemIndicators* release_system_indicators();
  ::abb::robot::SystemIndicators* mutable_system_indicators();
  void set_allocated_system_indicators(::abb::robot::SystemIndicators* system_indicators);

  // @@protoc_insertion_point(class_scope:abb.robot.RobotControllerDescription)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_system_indicators();
  void clear_has_system_indicators();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup > mechanical_units_groups_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask > rapid_tasks_;
  ::abb::robot::Header* header_;
  ::abb::robot::SystemIndicators* system_indicators_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotWareVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotWareVersion) */ {
 public:
  RobotWareVersion();
  virtual ~RobotWareVersion();

  RobotWareVersion(const RobotWareVersion& from);

  inline RobotWareVersion& operator=(const RobotWareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotWareVersion(RobotWareVersion&& from) noexcept
    : RobotWareVersion() {
    *this = ::std::move(from);
  }

  inline RobotWareVersion& operator=(RobotWareVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotWareVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotWareVersion* internal_default_instance() {
    return reinterpret_cast<const RobotWareVersion*>(
               &_RobotWareVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RobotWareVersion* other);
  friend void swap(RobotWareVersion& a, RobotWareVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotWareVersion* New() const final {
    return CreateMaybeMessage<RobotWareVersion>(NULL);
  }

  RobotWareVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotWareVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotWareVersion& from);
  void MergeFrom(const RobotWareVersion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotWareVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 major_number = 2;
  bool has_major_number() const;
  void clear_major_number();
  static const int kMajorNumberFieldNumber = 2;
  ::google::protobuf::uint32 major_number() const;
  void set_major_number(::google::protobuf::uint32 value);

  // optional uint32 minor_number = 3;
  bool has_minor_number() const;
  void clear_minor_number();
  static const int kMinorNumberFieldNumber = 3;
  ::google::protobuf::uint32 minor_number() const;
  void set_minor_number(::google::protobuf::uint32 value);

  // optional uint32 patch_number = 4;
  bool has_patch_number() const;
  void clear_patch_number();
  static const int kPatchNumberFieldNumber = 4;
  ::google::protobuf::uint32 patch_number() const;
  void set_patch_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:abb.robot.RobotWareVersion)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_major_number();
  void clear_has_major_number();
  void set_has_minor_number();
  void clear_has_minor_number();
  void set_has_patch_number();
  void clear_has_patch_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 major_number_;
  ::google::protobuf::uint32 minor_number_;
  ::google::protobuf::uint32 patch_number_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cartesian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Cartesian) */ {
 public:
  Cartesian();
  virtual ~Cartesian();

  Cartesian(const Cartesian& from);

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cartesian& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Cartesian* other);
  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cartesian* New() const final {
    return CreateMaybeMessage<Cartesian>(NULL);
  }

  Cartesian* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Cartesian& from);
  void MergeFrom(const Cartesian& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.robot.Cartesian)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(NULL);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double q1 = 1;
  bool has_q1() const;
  void clear_q1();
  static const int kQ1FieldNumber = 1;
  double q1() const;
  void set_q1(double value);

  // optional double q2 = 2;
  bool has_q2() const;
  void clear_q2();
  static const int kQ2FieldNumber = 2;
  double q2() const;
  void set_q2(double value);

  // optional double q3 = 3;
  bool has_q3() const;
  void clear_q3();
  static const int kQ3FieldNumber = 3;
  double q3() const;
  void set_q3(double value);

  // optional double q4 = 4;
  bool has_q4() const;
  void clear_q4();
  static const int kQ4FieldNumber = 4;
  double q4() const;
  void set_q4(double value);

  // @@protoc_insertion_point(class_scope:abb.robot.Quaternion)
 private:
  void set_has_q1();
  void clear_has_q1();
  void set_has_q2();
  void clear_has_q2();
  void set_has_q3();
  void clear_has_q3();
  void set_has_q4();
  void clear_has_q4();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double q1_;
  double q2_;
  double q3_;
  double q4_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.robot.Cartesian position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::abb::robot::Cartesian& _internal_position() const;
  public:
  const ::abb::robot::Cartesian& position() const;
  ::abb::robot::Cartesian* release_position();
  ::abb::robot::Cartesian* mutable_position();
  void set_allocated_position(::abb::robot::Cartesian* position);

  // optional .abb.robot.Quaternion rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  private:
  const ::abb::robot::Quaternion& _internal_rotation() const;
  public:
  const ::abb::robot::Quaternion& rotation() const;
  ::abb::robot::Quaternion* release_rotation();
  ::abb::robot::Quaternion* mutable_rotation();
  void set_allocated_rotation(::abb::robot::Quaternion* rotation);

  // @@protoc_insertion_point(class_scope:abb.robot.Pose)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_rotation();
  void clear_has_rotation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::robot::Cartesian* position_;
  ::abb::robot::Quaternion* rotation_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotIndicators : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RobotIndicators) */ {
 public:
  RobotIndicators();
  virtual ~RobotIndicators();

  RobotIndicators(const RobotIndicators& from);

  inline RobotIndicators& operator=(const RobotIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotIndicators(RobotIndicators&& from) noexcept
    : RobotIndicators() {
    *this = ::std::move(from);
  }

  inline RobotIndicators& operator=(RobotIndicators&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotIndicators& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotIndicators* internal_default_instance() {
    return reinterpret_cast<const RobotIndicators*>(
               &_RobotIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RobotIndicators* other);
  friend void swap(RobotIndicators& a, RobotIndicators& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotIndicators* New() const final {
    return CreateMaybeMessage<RobotIndicators>(NULL);
  }

  RobotIndicators* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotIndicators>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotIndicators& from);
  void MergeFrom(const RobotIndicators& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotIndicators* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool irb14000 = 1;
  bool has_irb14000() const;
  void clear_irb14000();
  static const int kIrb14000FieldNumber = 1;
  bool irb14000() const;
  void set_irb14000(bool value);

  // @@protoc_insertion_point(class_scope:abb.robot.RobotIndicators)
 private:
  void set_has_irb14000();
  void clear_has_irb14000();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool irb14000_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OptionIndicators : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.OptionIndicators) */ {
 public:
  OptionIndicators();
  virtual ~OptionIndicators();

  OptionIndicators(const OptionIndicators& from);

  inline OptionIndicators& operator=(const OptionIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionIndicators(OptionIndicators&& from) noexcept
    : OptionIndicators() {
    *this = ::std::move(from);
  }

  inline OptionIndicators& operator=(OptionIndicators&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionIndicators& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionIndicators* internal_default_instance() {
    return reinterpret_cast<const OptionIndicators*>(
               &_OptionIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(OptionIndicators* other);
  friend void swap(OptionIndicators& a, OptionIndicators& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionIndicators* New() const final {
    return CreateMaybeMessage<OptionIndicators>(NULL);
  }

  OptionIndicators* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionIndicators>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionIndicators& from);
  void MergeFrom(const OptionIndicators& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionIndicators* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool egm = 1;
  bool has_egm() const;
  void clear_egm();
  static const int kEgmFieldNumber = 1;
  bool egm() const;
  void set_egm(bool value);

  // optional bool leadthrough = 2;
  bool has_leadthrough() const;
  void clear_leadthrough();
  static const int kLeadthroughFieldNumber = 2;
  bool leadthrough() const;
  void set_leadthrough(bool value);

  // optional bool multimove = 3;
  bool has_multimove() const;
  void clear_multimove();
  static const int kMultimoveFieldNumber = 3;
  bool multimove() const;
  void set_multimove(bool value);

  // @@protoc_insertion_point(class_scope:abb.robot.OptionIndicators)
 private:
  void set_has_egm();
  void clear_has_egm();
  void set_has_leadthrough();
  void clear_has_leadthrough();
  void set_has_multimove();
  void clear_has_multimove();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool egm_;
  bool leadthrough_;
  bool multimove_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddInIndicators : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.AddInIndicators) */ {
 public:
  AddInIndicators();
  virtual ~AddInIndicators();

  AddInIndicators(const AddInIndicators& from);

  inline AddInIndicators& operator=(const AddInIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddInIndicators(AddInIndicators&& from) noexcept
    : AddInIndicators() {
    *this = ::std::move(from);
  }

  inline AddInIndicators& operator=(AddInIndicators&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddInIndicators& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddInIndicators* internal_default_instance() {
    return reinterpret_cast<const AddInIndicators*>(
               &_AddInIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AddInIndicators* other);
  friend void swap(AddInIndicators& a, AddInIndicators& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddInIndicators* New() const final {
    return CreateMaybeMessage<AddInIndicators>(NULL);
  }

  AddInIndicators* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddInIndicators>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddInIndicators& from);
  void MergeFrom(const AddInIndicators& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddInIndicators* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool smart_gripper = 1;
  bool has_smart_gripper() const;
  void clear_smart_gripper();
  static const int kSmartGripperFieldNumber = 1;
  bool smart_gripper() const;
  void set_smart_gripper(bool value);

  // optional bool state_machine_1_0 = 2;
  bool has_state_machine_1_0() const;
  void clear_state_machine_1_0();
  static const int kStateMachine10FieldNumber = 2;
  bool state_machine_1_0() const;
  void set_state_machine_1_0(bool value);

  // optional bool state_machine_1_1 = 3;
  bool has_state_machine_1_1() const;
  void clear_state_machine_1_1();
  static const int kStateMachine11FieldNumber = 3;
  bool state_machine_1_1() const;
  void set_state_machine_1_1(bool value);

  // @@protoc_insertion_point(class_scope:abb.robot.AddInIndicators)
 private:
  void set_has_smart_gripper();
  void clear_has_smart_gripper();
  void set_has_state_machine_1_0();
  void clear_has_state_machine_1_0();
  void set_has_state_machine_1_1();
  void clear_has_state_machine_1_1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool smart_gripper_;
  bool state_machine_1_0_;
  bool state_machine_1_1_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemIndicators : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.SystemIndicators) */ {
 public:
  SystemIndicators();
  virtual ~SystemIndicators();

  SystemIndicators(const SystemIndicators& from);

  inline SystemIndicators& operator=(const SystemIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemIndicators(SystemIndicators&& from) noexcept
    : SystemIndicators() {
    *this = ::std::move(from);
  }

  inline SystemIndicators& operator=(SystemIndicators&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemIndicators& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemIndicators* internal_default_instance() {
    return reinterpret_cast<const SystemIndicators*>(
               &_SystemIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SystemIndicators* other);
  friend void swap(SystemIndicators& a, SystemIndicators& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemIndicators* New() const final {
    return CreateMaybeMessage<SystemIndicators>(NULL);
  }

  SystemIndicators* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemIndicators>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SystemIndicators& from);
  void MergeFrom(const SystemIndicators& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemIndicators* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.robot.RobotIndicators robots = 1;
  bool has_robots() const;
  void clear_robots();
  static const int kRobotsFieldNumber = 1;
  private:
  const ::abb::robot::RobotIndicators& _internal_robots() const;
  public:
  const ::abb::robot::RobotIndicators& robots() const;
  ::abb::robot::RobotIndicators* release_robots();
  ::abb::robot::RobotIndicators* mutable_robots();
  void set_allocated_robots(::abb::robot::RobotIndicators* robots);

  // optional .abb.robot.OptionIndicators options = 2;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  private:
  const ::abb::robot::OptionIndicators& _internal_options() const;
  public:
  const ::abb::robot::OptionIndicators& options() const;
  ::abb::robot::OptionIndicators* release_options();
  ::abb::robot::OptionIndicators* mutable_options();
  void set_allocated_options(::abb::robot::OptionIndicators* options);

  // optional .abb.robot.AddInIndicators addins = 3;
  bool has_addins() const;
  void clear_addins();
  static const int kAddinsFieldNumber = 3;
  private:
  const ::abb::robot::AddInIndicators& _internal_addins() const;
  public:
  const ::abb::robot::AddInIndicators& addins() const;
  ::abb::robot::AddInIndicators* release_addins();
  ::abb::robot::AddInIndicators* mutable_addins();
  void set_allocated_addins(::abb::robot::AddInIndicators* addins);

  // @@protoc_insertion_point(class_scope:abb.robot.SystemIndicators)
 private:
  void set_has_robots();
  void clear_has_robots();
  void set_has_options();
  void clear_has_options();
  void set_has_addins();
  void clear_has_addins();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::abb::robot::RobotIndicators* robots_;
  ::abb::robot::OptionIndicators* options_;
  ::abb::robot::AddInIndicators* addins_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transmission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Transmission) */ {
 public:
  Transmission();
  virtual ~Transmission();

  Transmission(const Transmission& from);

  inline Transmission& operator=(const Transmission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transmission(Transmission&& from) noexcept
    : Transmission() {
    *this = ::std::move(from);
  }

  inline Transmission& operator=(Transmission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transmission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transmission* internal_default_instance() {
    return reinterpret_cast<const Transmission*>(
               &_Transmission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Transmission* other);
  friend void swap(Transmission& a, Transmission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transmission* New() const final {
    return CreateMaybeMessage<Transmission>(NULL);
  }

  Transmission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transmission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transmission& from);
  void MergeFrom(const Transmission& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transmission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool rotating_move = 2;
  bool has_rotating_move() const;
  void clear_rotating_move();
  static const int kRotatingMoveFieldNumber = 2;
  bool rotating_move() const;
  void set_rotating_move(bool value);

  // @@protoc_insertion_point(class_scope:abb.robot.Transmission)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_rotating_move();
  void clear_has_rotating_move();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool rotating_move_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Arm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Arm) */ {
 public:
  Arm();
  virtual ~Arm();

  Arm(const Arm& from);

  inline Arm& operator=(const Arm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Arm(Arm&& from) noexcept
    : Arm() {
    *this = ::std::move(from);
  }

  inline Arm& operator=(Arm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Arm* internal_default_instance() {
    return reinterpret_cast<const Arm*>(
               &_Arm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Arm* other);
  friend void swap(Arm& a, Arm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Arm* New() const final {
    return CreateMaybeMessage<Arm>(NULL);
  }

  Arm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Arm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Arm& from);
  void MergeFrom(const Arm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Arm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional double lower_joint_bound = 2;
  bool has_lower_joint_bound() const;
  void clear_lower_joint_bound();
  static const int kLowerJointBoundFieldNumber = 2;
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);

  // optional double upper_joint_bound = 3;
  bool has_upper_joint_bound() const;
  void clear_upper_joint_bound();
  static const int kUpperJointBoundFieldNumber = 3;
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);

  // @@protoc_insertion_point(class_scope:abb.robot.Arm)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_lower_joint_bound();
  void clear_has_lower_joint_bound();
  void set_has_upper_joint_bound();
  void clear_has_upper_joint_bound();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double lower_joint_bound_;
  double upper_joint_bound_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Joint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Joint) */ {
 public:
  Joint();
  virtual ~Joint();

  Joint(const Joint& from);

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(Joint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Joint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Joint* other);
  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Joint* New() const final {
    return CreateMaybeMessage<Joint>(NULL);
  }

  Joint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Joint& from);
  void MergeFrom(const Joint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .abb.robot.Arm arm = 4;
  bool has_arm() const;
  void clear_arm();
  static const int kArmFieldNumber = 4;
  private:
  const ::abb::robot::Arm& _internal_arm() const;
  public:
  const ::abb::robot::Arm& arm() const;
  ::abb::robot::Arm* release_arm();
  ::abb::robot::Arm* mutable_arm();
  void set_allocated_arm(::abb::robot::Arm* arm);

  // optional .abb.robot.Transmission transmission = 5;
  bool has_transmission() const;
  void clear_transmission();
  static const int kTransmissionFieldNumber = 5;
  private:
  const ::abb::robot::Transmission& _internal_transmission() const;
  public:
  const ::abb::robot::Transmission& transmission() const;
  ::abb::robot::Transmission* release_transmission();
  ::abb::robot::Transmission* mutable_transmission();
  void set_allocated_transmission(::abb::robot::Transmission* transmission);

  // optional int32 logical_axis = 2;
  bool has_logical_axis() const;
  void clear_logical_axis();
  static const int kLogicalAxisFieldNumber = 2;
  ::google::protobuf::int32 logical_axis() const;
  void set_logical_axis(::google::protobuf::int32 value);

  // optional int32 kinematic_axis_number = 3;
  bool has_kinematic_axis_number() const;
  void clear_kinematic_axis_number();
  static const int kKinematicAxisNumberFieldNumber = 3;
  ::google::protobuf::int32 kinematic_axis_number() const;
  void set_kinematic_axis_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:abb.robot.Joint)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_logical_axis();
  void clear_has_logical_axis();
  void set_has_kinematic_axis_number();
  void clear_has_kinematic_axis_number();
  void set_has_arm();
  void clear_has_arm();
  void set_has_transmission();
  void clear_has_transmission();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::abb::robot::Arm* arm_;
  ::abb::robot::Transmission* transmission_;
  ::google::protobuf::int32 logical_axis_;
  ::google::protobuf::int32 kinematic_axis_number_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StandardizedJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.StandardizedJoint) */ {
 public:
  StandardizedJoint();
  virtual ~StandardizedJoint();

  StandardizedJoint(const StandardizedJoint& from);

  inline StandardizedJoint& operator=(const StandardizedJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StandardizedJoint(StandardizedJoint&& from) noexcept
    : StandardizedJoint() {
    *this = ::std::move(from);
  }

  inline StandardizedJoint& operator=(StandardizedJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StandardizedJoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardizedJoint* internal_default_instance() {
    return reinterpret_cast<const StandardizedJoint*>(
               &_StandardizedJoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StandardizedJoint* other);
  friend void swap(StandardizedJoint& a, StandardizedJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StandardizedJoint* New() const final {
    return CreateMaybeMessage<StandardizedJoint>(NULL);
  }

  StandardizedJoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StandardizedJoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StandardizedJoint& from);
  void MergeFrom(const StandardizedJoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardizedJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string original_name = 1;
  bool has_original_name() const;
  void clear_original_name();
  static const int kOriginalNameFieldNumber = 1;
  const ::std::string& original_name() const;
  void set_original_name(const ::std::string& value);
  #if LANG_CXX11
  void set_original_name(::std::string&& value);
  #endif
  void set_original_name(const char* value);
  void set_original_name(const char* value, size_t size);
  ::std::string* mutable_original_name();
  ::std::string* release_original_name();
  void set_allocated_original_name(::std::string* original_name);

  // optional string standardized_name = 2;
  bool has_standardized_name() const;
  void clear_standardized_name();
  static const int kStandardizedNameFieldNumber = 2;
  const ::std::string& standardized_name() const;
  void set_standardized_name(const ::std::string& value);
  #if LANG_CXX11
  void set_standardized_name(::std::string&& value);
  #endif
  void set_standardized_name(const char* value);
  void set_standardized_name(const char* value, size_t size);
  ::std::string* mutable_standardized_name();
  ::std::string* release_standardized_name();
  void set_allocated_standardized_name(::std::string* standardized_name);

  // optional double lower_joint_bound = 4;
  bool has_lower_joint_bound() const;
  void clear_lower_joint_bound();
  static const int kLowerJointBoundFieldNumber = 4;
  double lower_joint_bound() const;
  void set_lower_joint_bound(double value);

  // optional double upper_joint_bound = 5;
  bool has_upper_joint_bound() const;
  void clear_upper_joint_bound();
  static const int kUpperJointBoundFieldNumber = 5;
  double upper_joint_bound() const;
  void set_upper_joint_bound(double value);

  // optional bool rotating_move = 3;
  bool has_rotating_move() const;
  void clear_rotating_move();
  static const int kRotatingMoveFieldNumber = 3;
  bool rotating_move() const;
  void set_rotating_move(bool value);

  // @@protoc_insertion_point(class_scope:abb.robot.StandardizedJoint)
 private:
  void set_has_original_name();
  void clear_has_original_name();
  void set_has_standardized_name();
  void clear_has_standardized_name();
  void set_has_rotating_move();
  void clear_has_rotating_move();
  void set_has_lower_joint_bound();
  void clear_has_lower_joint_bound();
  void set_has_upper_joint_bound();
  void clear_has_upper_joint_bound();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr original_name_;
  ::google::protobuf::internal::ArenaStringPtr standardized_name_;
  double lower_joint_bound_;
  double upper_joint_bound_;
  bool rotating_move_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Single : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Single) */ {
 public:
  Single();
  virtual ~Single();

  Single(const Single& from);

  inline Single& operator=(const Single& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Single(Single&& from) noexcept
    : Single() {
    *this = ::std::move(from);
  }

  inline Single& operator=(Single&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Single& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Single* internal_default_instance() {
    return reinterpret_cast<const Single*>(
               &_Single_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Single* other);
  friend void swap(Single& a, Single& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Single* New() const final {
    return CreateMaybeMessage<Single>(NULL);
  }

  Single* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Single>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Single& from);
  void MergeFrom(const Single& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Single* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  void clear_base_frame_moved_by();
  static const int kBaseFrameMovedByFieldNumber = 5;
  const ::std::string& base_frame_moved_by() const;
  void set_base_frame_moved_by(const ::std::string& value);
  #if LANG_CXX11
  void set_base_frame_moved_by(::std::string&& value);
  #endif
  void set_base_frame_moved_by(const char* value);
  void set_base_frame_moved_by(const char* value, size_t size);
  ::std::string* mutable_base_frame_moved_by();
  ::std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(::std::string* base_frame_moved_by);

  // optional .abb.robot.Joint joint = 3;
  bool has_joint() const;
  void clear_joint();
  static const int kJointFieldNumber = 3;
  private:
  const ::abb::robot::Joint& _internal_joint() const;
  public:
  const ::abb::robot::Joint& joint() const;
  ::abb::robot::Joint* release_joint();
  ::abb::robot::Joint* mutable_joint();
  void set_allocated_joint(::abb::robot::Joint* joint);

  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  void clear_base_frame();
  static const int kBaseFrameFieldNumber = 4;
  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  public:
  const ::abb::robot::Pose& base_frame() const;
  ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* base_frame);

  // @@protoc_insertion_point(class_scope:abb.robot.Single)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_joint();
  void clear_has_joint();
  void set_has_base_frame();
  void clear_has_base_frame();
  void set_has_base_frame_moved_by();
  void clear_has_base_frame_moved_by();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr base_frame_moved_by_;
  ::abb::robot::Joint* joint_;
  ::abb::robot::Pose* base_frame_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.Robot) */ {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Robot* other);
  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const final {
    return CreateMaybeMessage<Robot>(NULL);
  }

  Robot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .abb.robot.Joint joints = 3;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 3;
  ::abb::robot::Joint* mutable_joints(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >*
      mutable_joints();
  const ::abb::robot::Joint& joints(int index) const;
  ::abb::robot::Joint* add_joints();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >&
      joints() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string base_frame_moved_by = 5;
  bool has_base_frame_moved_by() const;
  void clear_base_frame_moved_by();
  static const int kBaseFrameMovedByFieldNumber = 5;
  const ::std::string& base_frame_moved_by() const;
  void set_base_frame_moved_by(const ::std::string& value);
  #if LANG_CXX11
  void set_base_frame_moved_by(::std::string&& value);
  #endif
  void set_base_frame_moved_by(const char* value);
  void set_base_frame_moved_by(const char* value, size_t size);
  ::std::string* mutable_base_frame_moved_by();
  ::std::string* release_base_frame_moved_by();
  void set_allocated_base_frame_moved_by(::std::string* base_frame_moved_by);

  // optional .abb.robot.Pose base_frame = 4;
  bool has_base_frame() const;
  void clear_base_frame();
  static const int kBaseFrameFieldNumber = 4;
  private:
  const ::abb::robot::Pose& _internal_base_frame() const;
  public:
  const ::abb::robot::Pose& base_frame() const;
  ::abb::robot::Pose* release_base_frame();
  ::abb::robot::Pose* mutable_base_frame();
  void set_allocated_base_frame(::abb::robot::Pose* base_frame);

  // @@protoc_insertion_point(class_scope:abb.robot.Robot)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_base_frame();
  void clear_has_base_frame();
  void set_has_base_frame_moved_by();
  void clear_has_base_frame_moved_by();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint > joints_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr base_frame_moved_by_;
  ::abb::robot::Pose* base_frame_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MechanicalUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnit) */ {
 public:
  MechanicalUnit();
  virtual ~MechanicalUnit();

  MechanicalUnit(const MechanicalUnit& from);

  inline MechanicalUnit& operator=(const MechanicalUnit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MechanicalUnit(MechanicalUnit&& from) noexcept
    : MechanicalUnit() {
    *this = ::std::move(from);
  }

  inline MechanicalUnit& operator=(MechanicalUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MechanicalUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MechanicalUnit* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnit*>(
               &_MechanicalUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MechanicalUnit* other);
  friend void swap(MechanicalUnit& a, MechanicalUnit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MechanicalUnit* New() const final {
    return CreateMaybeMessage<MechanicalUnit>(NULL);
  }

  MechanicalUnit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MechanicalUnit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MechanicalUnit& from);
  void MergeFrom(const MechanicalUnit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MechanicalUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MechanicalUnit_Type Type;
  static const Type UNDEFINED =
    MechanicalUnit_Type_UNDEFINED;
  static const Type NONE =
    MechanicalUnit_Type_NONE;
  static const Type TCP_ROBOT =
    MechanicalUnit_Type_TCP_ROBOT;
  static const Type ROBOT =
    MechanicalUnit_Type_ROBOT;
  static const Type SINGLE =
    MechanicalUnit_Type_SINGLE;
  static inline bool Type_IsValid(int value) {
    return MechanicalUnit_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MechanicalUnit_Type_Type_MIN;
  static const Type Type_MAX =
    MechanicalUnit_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MechanicalUnit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MechanicalUnit_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MechanicalUnit_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MechanicalUnit_Type_Parse(name, value);
  }

  typedef MechanicalUnit_Mode Mode;
  static const Mode DEACTIVATED =
    MechanicalUnit_Mode_DEACTIVATED;
  static const Mode ACTIVATED =
    MechanicalUnit_Mode_ACTIVATED;
  static inline bool Mode_IsValid(int value) {
    return MechanicalUnit_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MechanicalUnit_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MechanicalUnit_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MechanicalUnit_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MechanicalUnit_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MechanicalUnit_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MechanicalUnit_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .abb.robot.Single singles = 3;
  int singles_size() const;
  void clear_singles();
  static const int kSinglesFieldNumber = 3;
  ::abb::robot::Single* mutable_singles(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >*
      mutable_singles();
  const ::abb::robot::Single& singles(int index) const;
  ::abb::robot::Single* add_singles();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >&
      singles() const;

  // repeated .abb.robot.StandardizedJoint standardized_joints = 12;
  int standardized_joints_size() const;
  void clear_standardized_joints();
  static const int kStandardizedJointsFieldNumber = 12;
  ::abb::robot::StandardizedJoint* mutable_standardized_joints(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >*
      mutable_standardized_joints();
  const ::abb::robot::StandardizedJoint& standardized_joints(int index) const;
  ::abb::robot::StandardizedJoint* add_standardized_joints();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >&
      standardized_joints() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string task_name = 5;
  bool has_task_name() const;
  void clear_task_name();
  static const int kTaskNameFieldNumber = 5;
  const ::std::string& task_name() const;
  void set_task_name(const ::std::string& value);
  #if LANG_CXX11
  void set_task_name(::std::string&& value);
  #endif
  void set_task_name(const char* value);
  void set_task_name(const char* value, size_t size);
  ::std::string* mutable_task_name();
  ::std::string* release_task_name();
  void set_allocated_task_name(::std::string* task_name);

  // optional string is_integrated_unit = 8;
  bool has_is_integrated_unit() const;
  void clear_is_integrated_unit();
  static const int kIsIntegratedUnitFieldNumber = 8;
  const ::std::string& is_integrated_unit() const;
  void set_is_integrated_unit(const ::std::string& value);
  #if LANG_CXX11
  void set_is_integrated_unit(::std::string&& value);
  #endif
  void set_is_integrated_unit(const char* value);
  void set_is_integrated_unit(const char* value, size_t size);
  ::std::string* mutable_is_integrated_unit();
  ::std::string* release_is_integrated_unit();
  void set_allocated_is_integrated_unit(::std::string* is_integrated_unit);

  // optional string has_integrated_unit = 9;
  bool has_has_integrated_unit() const;
  void clear_has_integrated_unit();
  static const int kHasIntegratedUnitFieldNumber = 9;
  const ::std::string& has_integrated_unit() const;
  void set_has_integrated_unit(const ::std::string& value);
  #if LANG_CXX11
  void set_has_integrated_unit(::std::string&& value);
  #endif
  void set_has_integrated_unit(const char* value);
  void set_has_integrated_unit(const char* value, size_t size);
  ::std::string* mutable_has_integrated_unit();
  ::std::string* release_has_integrated_unit();
  void set_allocated_has_integrated_unit(::std::string* has_integrated_unit);

  // optional string status = 10;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 10;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // optional .abb.robot.Robot robot = 2;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 2;
  private:
  const ::abb::robot::Robot& _internal_robot() const;
  public:
  const ::abb::robot::Robot& robot() const;
  ::abb::robot::Robot* release_robot();
  ::abb::robot::Robot* mutable_robot();
  void set_allocated_robot(::abb::robot::Robot* robot);

  // optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::abb::robot::MechanicalUnit_Type type() const;
  void set_type(::abb::robot::MechanicalUnit_Type value);

  // optional int32 axes = 6;
  bool has_axes() const;
  void clear_axes();
  static const int kAxesFieldNumber = 6;
  ::google::protobuf::int32 axes() const;
  void set_axes(::google::protobuf::int32 value);

  // optional int32 axes_total = 7;
  bool has_axes_total() const;
  void clear_axes_total();
  static const int kAxesTotalFieldNumber = 7;
  ::google::protobuf::int32 axes_total() const;
  void set_axes_total(::google::protobuf::int32 value);

  // optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 11;
  ::abb::robot::MechanicalUnit_Mode mode() const;
  void set_mode(::abb::robot::MechanicalUnit_Mode value);

  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnit)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_robot();
  void clear_has_robot();
  void set_has_type();
  void clear_has_type();
  void set_has_task_name();
  void clear_has_task_name();
  void set_has_axes();
  void clear_has_axes();
  void set_has_axes_total();
  void clear_has_axes_total();
  void set_has_is_integrated_unit();
  void clear_has_is_integrated_unit();
  void set_has_has_integrated_unit();
  void clear_has_has_integrated_unit();
  void set_has_status();
  void clear_has_status();
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::Single > singles_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint > standardized_joints_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr task_name_;
  ::google::protobuf::internal::ArenaStringPtr is_integrated_unit_;
  ::google::protobuf::internal::ArenaStringPtr has_integrated_unit_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::abb::robot::Robot* robot_;
  int type_;
  ::google::protobuf::int32 axes_;
  ::google::protobuf::int32 axes_total_;
  int mode_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MechanicalUnitGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.MechanicalUnitGroup) */ {
 public:
  MechanicalUnitGroup();
  virtual ~MechanicalUnitGroup();

  MechanicalUnitGroup(const MechanicalUnitGroup& from);

  inline MechanicalUnitGroup& operator=(const MechanicalUnitGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MechanicalUnitGroup(MechanicalUnitGroup&& from) noexcept
    : MechanicalUnitGroup() {
    *this = ::std::move(from);
  }

  inline MechanicalUnitGroup& operator=(MechanicalUnitGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MechanicalUnitGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MechanicalUnitGroup* internal_default_instance() {
    return reinterpret_cast<const MechanicalUnitGroup*>(
               &_MechanicalUnitGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MechanicalUnitGroup* other);
  friend void swap(MechanicalUnitGroup& a, MechanicalUnitGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MechanicalUnitGroup* New() const final {
    return CreateMaybeMessage<MechanicalUnitGroup>(NULL);
  }

  MechanicalUnitGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MechanicalUnitGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MechanicalUnitGroup& from);
  void MergeFrom(const MechanicalUnitGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MechanicalUnitGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .abb.robot.MechanicalUnit mechanical_units = 3;
  int mechanical_units_size() const;
  void clear_mechanical_units();
  static const int kMechanicalUnitsFieldNumber = 3;
  ::abb::robot::MechanicalUnit* mutable_mechanical_units(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >*
      mutable_mechanical_units();
  const ::abb::robot::MechanicalUnit& mechanical_units(int index) const;
  ::abb::robot::MechanicalUnit* add_mechanical_units();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >&
      mechanical_units() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .abb.robot.MechanicalUnit robot = 2;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 2;
  private:
  const ::abb::robot::MechanicalUnit& _internal_robot() const;
  public:
  const ::abb::robot::MechanicalUnit& robot() const;
  ::abb::robot::MechanicalUnit* release_robot();
  ::abb::robot::MechanicalUnit* mutable_robot();
  void set_allocated_robot(::abb::robot::MechanicalUnit* robot);

  // @@protoc_insertion_point(class_scope:abb.robot.MechanicalUnitGroup)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_robot();
  void clear_has_robot();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit > mechanical_units_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::abb::robot::MechanicalUnit* robot_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RAPIDModule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDModule) */ {
 public:
  RAPIDModule();
  virtual ~RAPIDModule();

  RAPIDModule(const RAPIDModule& from);

  inline RAPIDModule& operator=(const RAPIDModule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RAPIDModule(RAPIDModule&& from) noexcept
    : RAPIDModule() {
    *this = ::std::move(from);
  }

  inline RAPIDModule& operator=(RAPIDModule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAPIDModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RAPIDModule* internal_default_instance() {
    return reinterpret_cast<const RAPIDModule*>(
               &_RAPIDModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RAPIDModule* other);
  friend void swap(RAPIDModule& a, RAPIDModule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RAPIDModule* New() const final {
    return CreateMaybeMessage<RAPIDModule>(NULL);
  }

  RAPIDModule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RAPIDModule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RAPIDModule& from);
  void MergeFrom(const RAPIDModule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RAPIDModule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDModule)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RAPIDTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.robot.RAPIDTask) */ {
 public:
  RAPIDTask();
  virtual ~RAPIDTask();

  RAPIDTask(const RAPIDTask& from);

  inline RAPIDTask& operator=(const RAPIDTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RAPIDTask(RAPIDTask&& from) noexcept
    : RAPIDTask() {
    *this = ::std::move(from);
  }

  inline RAPIDTask& operator=(RAPIDTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAPIDTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RAPIDTask* internal_default_instance() {
    return reinterpret_cast<const RAPIDTask*>(
               &_RAPIDTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RAPIDTask* other);
  friend void swap(RAPIDTask& a, RAPIDTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RAPIDTask* New() const final {
    return CreateMaybeMessage<RAPIDTask>(NULL);
  }

  RAPIDTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RAPIDTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RAPIDTask& from);
  void MergeFrom(const RAPIDTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RAPIDTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RAPIDTask_ExecutionState ExecutionState;
  static const ExecutionState UNKNOWN =
    RAPIDTask_ExecutionState_UNKNOWN;
  static const ExecutionState READY =
    RAPIDTask_ExecutionState_READY;
  static const ExecutionState STOPPED =
    RAPIDTask_ExecutionState_STOPPED;
  static const ExecutionState STARTED =
    RAPIDTask_ExecutionState_STARTED;
  static const ExecutionState UNINITIALIZED =
    RAPIDTask_ExecutionState_UNINITIALIZED;
  static inline bool ExecutionState_IsValid(int value) {
    return RAPIDTask_ExecutionState_IsValid(value);
  }
  static const ExecutionState ExecutionState_MIN =
    RAPIDTask_ExecutionState_ExecutionState_MIN;
  static const ExecutionState ExecutionState_MAX =
    RAPIDTask_ExecutionState_ExecutionState_MAX;
  static const int ExecutionState_ARRAYSIZE =
    RAPIDTask_ExecutionState_ExecutionState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExecutionState_descriptor() {
    return RAPIDTask_ExecutionState_descriptor();
  }
  static inline const ::std::string& ExecutionState_Name(ExecutionState value) {
    return RAPIDTask_ExecutionState_Name(value);
  }
  static inline bool ExecutionState_Parse(const ::std::string& name,
      ExecutionState* value) {
    return RAPIDTask_ExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .abb.robot.RAPIDModule modules = 5;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 5;
  ::abb::robot::RAPIDModule* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >*
      mutable_modules();
  const ::abb::robot::RAPIDModule& modules(int index) const;
  ::abb::robot::RAPIDModule* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >&
      modules() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool is_motion_task = 2;
  bool has_is_motion_task() const;
  void clear_is_motion_task();
  static const int kIsMotionTaskFieldNumber = 2;
  bool is_motion_task() const;
  void set_is_motion_task(bool value);

  // optional bool is_active = 3;
  bool has_is_active() const;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 3;
  bool is_active() const;
  void set_is_active(bool value);

  // optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
  bool has_execution_state() const;
  void clear_execution_state();
  static const int kExecutionStateFieldNumber = 4;
  ::abb::robot::RAPIDTask_ExecutionState execution_state() const;
  void set_execution_state(::abb::robot::RAPIDTask_ExecutionState value);

  // @@protoc_insertion_point(class_scope:abb.robot.RAPIDTask)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_is_motion_task();
  void clear_has_is_motion_task();
  void set_has_is_active();
  void clear_has_is_active();
  void set_has_execution_state();
  void clear_has_execution_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule > modules_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool is_motion_task_;
  bool is_active_;
  int execution_state_;
  friend struct ::protobuf_robot_5fcontroller_5fdescription_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional string ip_address = 1;
inline bool Header::has_ip_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_ip_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip_address();
}
inline const ::std::string& Header::ip_address() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.ip_address)
  return ip_address_.GetNoArena();
}
inline void Header::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.ip_address)
}
#if LANG_CXX11
inline void Header::set_ip_address(::std::string&& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Header.ip_address)
}
#endif
inline void Header::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.ip_address)
}
inline void Header::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.ip_address)
}
inline ::std::string* Header::mutable_ip_address() {
  set_has_ip_address();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_ip_address() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.ip_address)
  if (!has_ip_address()) {
    return NULL;
  }
  clear_has_ip_address();
  return ip_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.ip_address)
}

// optional uint32 rws_port_number = 2;
inline bool Header::has_rws_port_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_rws_port_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_rws_port_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_rws_port_number() {
  rws_port_number_ = 0u;
  clear_has_rws_port_number();
}
inline ::google::protobuf::uint32 Header::rws_port_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.rws_port_number)
  return rws_port_number_;
}
inline void Header::set_rws_port_number(::google::protobuf::uint32 value) {
  set_has_rws_port_number();
  rws_port_number_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Header.rws_port_number)
}

// optional .abb.robot.RobotWareVersion robot_ware_version = 3;
inline bool Header::has_robot_ware_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_robot_ware_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_robot_ware_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_robot_ware_version() {
  if (robot_ware_version_ != NULL) robot_ware_version_->Clear();
  clear_has_robot_ware_version();
}
inline const ::abb::robot::RobotWareVersion& Header::_internal_robot_ware_version() const {
  return *robot_ware_version_;
}
inline const ::abb::robot::RobotWareVersion& Header::robot_ware_version() const {
  const ::abb::robot::RobotWareVersion* p = robot_ware_version_;
  // @@protoc_insertion_point(field_get:abb.robot.Header.robot_ware_version)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::RobotWareVersion*>(
      &::abb::robot::_RobotWareVersion_default_instance_);
}
inline ::abb::robot::RobotWareVersion* Header::release_robot_ware_version() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.robot_ware_version)
  clear_has_robot_ware_version();
  ::abb::robot::RobotWareVersion* temp = robot_ware_version_;
  robot_ware_version_ = NULL;
  return temp;
}
inline ::abb::robot::RobotWareVersion* Header::mutable_robot_ware_version() {
  set_has_robot_ware_version();
  if (robot_ware_version_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotWareVersion>(GetArenaNoVirtual());
    robot_ware_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.robot_ware_version)
  return robot_ware_version_;
}
inline void Header::set_allocated_robot_ware_version(::abb::robot::RobotWareVersion* robot_ware_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_ware_version_;
  }
  if (robot_ware_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot_ware_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_ware_version, submessage_arena);
    }
    set_has_robot_ware_version();
  } else {
    clear_has_robot_ware_version();
  }
  robot_ware_version_ = robot_ware_version;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.robot_ware_version)
}

// optional string system_name = 4;
inline bool Header::has_system_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_system_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_system_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_system_name() {
  system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system_name();
}
inline const ::std::string& Header::system_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_name)
  return system_name_.GetNoArena();
}
inline void Header::set_system_name(const ::std::string& value) {
  set_has_system_name();
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_name)
}
#if LANG_CXX11
inline void Header::set_system_name(::std::string&& value) {
  set_has_system_name();
  system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Header.system_name)
}
#endif
inline void Header::set_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_system_name();
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.system_name)
}
inline void Header::set_system_name(const char* value, size_t size) {
  set_has_system_name();
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.system_name)
}
inline ::std::string* Header::mutable_system_name() {
  set_has_system_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_name)
  return system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_system_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_name)
  if (!has_system_name()) {
    return NULL;
  }
  clear_has_system_name();
  return system_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_system_name(::std::string* system_name) {
  if (system_name != NULL) {
    set_has_system_name();
  } else {
    clear_has_system_name();
  }
  system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_name)
}

// optional string system_type = 5;
inline bool Header::has_system_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_system_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_system_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_system_type() {
  system_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system_type();
}
inline const ::std::string& Header::system_type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.system_type)
  return system_type_.GetNoArena();
}
inline void Header::set_system_type(const ::std::string& value) {
  set_has_system_type();
  system_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Header.system_type)
}
#if LANG_CXX11
inline void Header::set_system_type(::std::string&& value) {
  set_has_system_type();
  system_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Header.system_type)
}
#endif
inline void Header::set_system_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_system_type();
  system_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.system_type)
}
inline void Header::set_system_type(const char* value, size_t size) {
  set_has_system_type();
  system_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.system_type)
}
inline ::std::string* Header::mutable_system_type() {
  set_has_system_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.system_type)
  return system_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_system_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Header.system_type)
  if (!has_system_type()) {
    return NULL;
  }
  clear_has_system_type();
  return system_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_system_type(::std::string* system_type) {
  if (system_type != NULL) {
    set_has_system_type();
  } else {
    clear_has_system_type();
  }
  system_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_type);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Header.system_type)
}

// repeated string options = 6;
inline int Header::options_size() const {
  return options_.size();
}
inline void Header::clear_options() {
  options_.Clear();
}
inline const ::std::string& Header::options(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.Header.options)
  return options_.Get(index);
}
inline ::std::string* Header::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.Header.options)
  return options_.Mutable(index);
}
inline void Header::set_options(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
  options_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Header::set_options(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:abb.robot.Header.options)
  options_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Header::set_options(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:abb.robot.Header.options)
}
inline void Header::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Header.options)
}
inline ::std::string* Header::add_options() {
  // @@protoc_insertion_point(field_add_mutable:abb.robot.Header.options)
  return options_.Add();
}
inline void Header::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
#if LANG_CXX11
inline void Header::add_options(::std::string&& value) {
  options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:abb.robot.Header.options)
}
#endif
inline void Header::add_options(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:abb.robot.Header.options)
}
inline void Header::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:abb.robot.Header.options)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Header::options() const {
  // @@protoc_insertion_point(field_list:abb.robot.Header.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Header::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Header.options)
  return &options_;
}

// -------------------------------------------------------------------

// RobotControllerDescription

// optional .abb.robot.Header header = 1;
inline bool RobotControllerDescription::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotControllerDescription::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotControllerDescription::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotControllerDescription::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::abb::robot::Header& RobotControllerDescription::_internal_header() const {
  return *header_;
}
inline const ::abb::robot::Header& RobotControllerDescription::header() const {
  const ::abb::robot::Header* p = header_;
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.header)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Header*>(
      &::abb::robot::_Header_default_instance_);
}
inline ::abb::robot::Header* RobotControllerDescription::release_header() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.header)
  clear_has_header();
  ::abb::robot::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::abb::robot::Header* RobotControllerDescription::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.header)
  return header_;
}
inline void RobotControllerDescription::set_allocated_header(::abb::robot::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.header)
}

// optional .abb.robot.SystemIndicators system_indicators = 2;
inline bool RobotControllerDescription::has_system_indicators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotControllerDescription::set_has_system_indicators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotControllerDescription::clear_has_system_indicators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotControllerDescription::clear_system_indicators() {
  if (system_indicators_ != NULL) system_indicators_->Clear();
  clear_has_system_indicators();
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::_internal_system_indicators() const {
  return *system_indicators_;
}
inline const ::abb::robot::SystemIndicators& RobotControllerDescription::system_indicators() const {
  const ::abb::robot::SystemIndicators* p = system_indicators_;
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.system_indicators)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::SystemIndicators*>(
      &::abb::robot::_SystemIndicators_default_instance_);
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::release_system_indicators() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotControllerDescription.system_indicators)
  clear_has_system_indicators();
  ::abb::robot::SystemIndicators* temp = system_indicators_;
  system_indicators_ = NULL;
  return temp;
}
inline ::abb::robot::SystemIndicators* RobotControllerDescription::mutable_system_indicators() {
  set_has_system_indicators();
  if (system_indicators_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::SystemIndicators>(GetArenaNoVirtual());
    system_indicators_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.system_indicators)
  return system_indicators_;
}
inline void RobotControllerDescription::set_allocated_system_indicators(::abb::robot::SystemIndicators* system_indicators) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete system_indicators_;
  }
  if (system_indicators) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      system_indicators = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, system_indicators, submessage_arena);
    }
    set_has_system_indicators();
  } else {
    clear_has_system_indicators();
  }
  system_indicators_ = system_indicators;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotControllerDescription.system_indicators)
}

// repeated .abb.robot.MechanicalUnitGroup mechanical_units_groups = 3;
inline int RobotControllerDescription::mechanical_units_groups_size() const {
  return mechanical_units_groups_.size();
}
inline void RobotControllerDescription::clear_mechanical_units_groups() {
  mechanical_units_groups_.Clear();
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::mutable_mechanical_units_groups(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return mechanical_units_groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >*
RobotControllerDescription::mutable_mechanical_units_groups() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return &mechanical_units_groups_;
}
inline const ::abb::robot::MechanicalUnitGroup& RobotControllerDescription::mechanical_units_groups(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return mechanical_units_groups_.Get(index);
}
inline ::abb::robot::MechanicalUnitGroup* RobotControllerDescription::add_mechanical_units_groups() {
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return mechanical_units_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnitGroup >&
RobotControllerDescription::mechanical_units_groups() const {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.mechanical_units_groups)
  return mechanical_units_groups_;
}

// repeated .abb.robot.RAPIDTask rapid_tasks = 4;
inline int RobotControllerDescription::rapid_tasks_size() const {
  return rapid_tasks_.size();
}
inline void RobotControllerDescription::clear_rapid_tasks() {
  rapid_tasks_.Clear();
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::mutable_rapid_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotControllerDescription.rapid_tasks)
  return rapid_tasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >*
RobotControllerDescription::mutable_rapid_tasks() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RobotControllerDescription.rapid_tasks)
  return &rapid_tasks_;
}
inline const ::abb::robot::RAPIDTask& RobotControllerDescription::rapid_tasks(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotControllerDescription.rapid_tasks)
  return rapid_tasks_.Get(index);
}
inline ::abb::robot::RAPIDTask* RobotControllerDescription::add_rapid_tasks() {
  // @@protoc_insertion_point(field_add:abb.robot.RobotControllerDescription.rapid_tasks)
  return rapid_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDTask >&
RobotControllerDescription::rapid_tasks() const {
  // @@protoc_insertion_point(field_list:abb.robot.RobotControllerDescription.rapid_tasks)
  return rapid_tasks_;
}

// -------------------------------------------------------------------

// RobotWareVersion

// optional string name = 1;
inline bool RobotWareVersion::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotWareVersion::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotWareVersion::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotWareVersion::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RobotWareVersion::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.name)
  return name_.GetNoArena();
}
inline void RobotWareVersion::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.name)
}
#if LANG_CXX11
inline void RobotWareVersion::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.RobotWareVersion.name)
}
#endif
inline void RobotWareVersion::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.RobotWareVersion.name)
}
inline void RobotWareVersion::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.RobotWareVersion.name)
}
inline ::std::string* RobotWareVersion::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RobotWareVersion.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotWareVersion::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RobotWareVersion.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotWareVersion::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RobotWareVersion.name)
}

// optional uint32 major_number = 2;
inline bool RobotWareVersion::has_major_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotWareVersion::set_has_major_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotWareVersion::clear_has_major_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotWareVersion::clear_major_number() {
  major_number_ = 0u;
  clear_has_major_number();
}
inline ::google::protobuf::uint32 RobotWareVersion::major_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.major_number)
  return major_number_;
}
inline void RobotWareVersion::set_major_number(::google::protobuf::uint32 value) {
  set_has_major_number();
  major_number_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.major_number)
}

// optional uint32 minor_number = 3;
inline bool RobotWareVersion::has_minor_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotWareVersion::set_has_minor_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotWareVersion::clear_has_minor_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotWareVersion::clear_minor_number() {
  minor_number_ = 0u;
  clear_has_minor_number();
}
inline ::google::protobuf::uint32 RobotWareVersion::minor_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.minor_number)
  return minor_number_;
}
inline void RobotWareVersion::set_minor_number(::google::protobuf::uint32 value) {
  set_has_minor_number();
  minor_number_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.minor_number)
}

// optional uint32 patch_number = 4;
inline bool RobotWareVersion::has_patch_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotWareVersion::set_has_patch_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotWareVersion::clear_has_patch_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotWareVersion::clear_patch_number() {
  patch_number_ = 0u;
  clear_has_patch_number();
}
inline ::google::protobuf::uint32 RobotWareVersion::patch_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotWareVersion.patch_number)
  return patch_number_;
}
inline void RobotWareVersion::set_patch_number(::google::protobuf::uint32 value) {
  set_has_patch_number();
  patch_number_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RobotWareVersion.patch_number)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cartesian::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cartesian::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cartesian::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.x)
  return x_;
}
inline void Cartesian::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cartesian::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cartesian::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cartesian::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.y)
  return y_;
}
inline void Cartesian::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cartesian::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cartesian::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cartesian::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.robot.Cartesian.z)
  return z_;
}
inline void Cartesian::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Cartesian.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double q1 = 1;
inline bool Quaternion::has_q1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_q1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_q1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_q1() {
  q1_ = 0;
  clear_has_q1();
}
inline double Quaternion::q1() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q1)
  return q1_;
}
inline void Quaternion::set_q1(double value) {
  set_has_q1();
  q1_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q1)
}

// optional double q2 = 2;
inline bool Quaternion::has_q2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_q2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_q2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_q2() {
  q2_ = 0;
  clear_has_q2();
}
inline double Quaternion::q2() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q2)
  return q2_;
}
inline void Quaternion::set_q2(double value) {
  set_has_q2();
  q2_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q2)
}

// optional double q3 = 3;
inline bool Quaternion::has_q3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_q3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_q3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_q3() {
  q3_ = 0;
  clear_has_q3();
}
inline double Quaternion::q3() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q3)
  return q3_;
}
inline void Quaternion::set_q3(double value) {
  set_has_q3();
  q3_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q3)
}

// optional double q4 = 4;
inline bool Quaternion::has_q4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_q4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_q4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_q4() {
  q4_ = 0;
  clear_has_q4();
}
inline double Quaternion::q4() const {
  // @@protoc_insertion_point(field_get:abb.robot.Quaternion.q4)
  return q4_;
}
inline void Quaternion::set_q4(double value) {
  set_has_q4();
  q4_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Quaternion.q4)
}

// -------------------------------------------------------------------

// Pose

// optional .abb.robot.Cartesian position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::abb::robot::Cartesian& Pose::_internal_position() const {
  return *position_;
}
inline const ::abb::robot::Cartesian& Pose::position() const {
  const ::abb::robot::Cartesian* p = position_;
  // @@protoc_insertion_point(field_get:abb.robot.Pose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Cartesian*>(
      &::abb::robot::_Cartesian_default_instance_);
}
inline ::abb::robot::Cartesian* Pose::release_position() {
  // @@protoc_insertion_point(field_release:abb.robot.Pose.position)
  clear_has_position();
  ::abb::robot::Cartesian* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::abb::robot::Cartesian* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Cartesian>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.position)
  return position_;
}
inline void Pose::set_allocated_position(::abb::robot::Cartesian* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.position)
}

// optional .abb.robot.Quaternion rotation = 2;
inline bool Pose::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::abb::robot::Quaternion& Pose::_internal_rotation() const {
  return *rotation_;
}
inline const ::abb::robot::Quaternion& Pose::rotation() const {
  const ::abb::robot::Quaternion* p = rotation_;
  // @@protoc_insertion_point(field_get:abb.robot.Pose.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Quaternion*>(
      &::abb::robot::_Quaternion_default_instance_);
}
inline ::abb::robot::Quaternion* Pose::release_rotation() {
  // @@protoc_insertion_point(field_release:abb.robot.Pose.rotation)
  clear_has_rotation();
  ::abb::robot::Quaternion* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::abb::robot::Quaternion* Pose::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Quaternion>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Pose.rotation)
  return rotation_;
}
inline void Pose::set_allocated_rotation(::abb::robot::Quaternion* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Pose.rotation)
}

// -------------------------------------------------------------------

// RobotIndicators

// optional bool irb14000 = 1;
inline bool RobotIndicators::has_irb14000() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotIndicators::set_has_irb14000() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotIndicators::clear_has_irb14000() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotIndicators::clear_irb14000() {
  irb14000_ = false;
  clear_has_irb14000();
}
inline bool RobotIndicators::irb14000() const {
  // @@protoc_insertion_point(field_get:abb.robot.RobotIndicators.irb14000)
  return irb14000_;
}
inline void RobotIndicators::set_irb14000(bool value) {
  set_has_irb14000();
  irb14000_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RobotIndicators.irb14000)
}

// -------------------------------------------------------------------

// OptionIndicators

// optional bool egm = 1;
inline bool OptionIndicators::has_egm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptionIndicators::set_has_egm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptionIndicators::clear_has_egm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptionIndicators::clear_egm() {
  egm_ = false;
  clear_has_egm();
}
inline bool OptionIndicators::egm() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.egm)
  return egm_;
}
inline void OptionIndicators::set_egm(bool value) {
  set_has_egm();
  egm_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.egm)
}

// optional bool leadthrough = 2;
inline bool OptionIndicators::has_leadthrough() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptionIndicators::set_has_leadthrough() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptionIndicators::clear_has_leadthrough() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptionIndicators::clear_leadthrough() {
  leadthrough_ = false;
  clear_has_leadthrough();
}
inline bool OptionIndicators::leadthrough() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.leadthrough)
  return leadthrough_;
}
inline void OptionIndicators::set_leadthrough(bool value) {
  set_has_leadthrough();
  leadthrough_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.leadthrough)
}

// optional bool multimove = 3;
inline bool OptionIndicators::has_multimove() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OptionIndicators::set_has_multimove() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OptionIndicators::clear_has_multimove() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OptionIndicators::clear_multimove() {
  multimove_ = false;
  clear_has_multimove();
}
inline bool OptionIndicators::multimove() const {
  // @@protoc_insertion_point(field_get:abb.robot.OptionIndicators.multimove)
  return multimove_;
}
inline void OptionIndicators::set_multimove(bool value) {
  set_has_multimove();
  multimove_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.OptionIndicators.multimove)
}

// -------------------------------------------------------------------

// AddInIndicators

// optional bool smart_gripper = 1;
inline bool AddInIndicators::has_smart_gripper() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddInIndicators::set_has_smart_gripper() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddInIndicators::clear_has_smart_gripper() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddInIndicators::clear_smart_gripper() {
  smart_gripper_ = false;
  clear_has_smart_gripper();
}
inline bool AddInIndicators::smart_gripper() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.smart_gripper)
  return smart_gripper_;
}
inline void AddInIndicators::set_smart_gripper(bool value) {
  set_has_smart_gripper();
  smart_gripper_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.smart_gripper)
}

// optional bool state_machine_1_0 = 2;
inline bool AddInIndicators::has_state_machine_1_0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddInIndicators::set_has_state_machine_1_0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddInIndicators::clear_has_state_machine_1_0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddInIndicators::clear_state_machine_1_0() {
  state_machine_1_0_ = false;
  clear_has_state_machine_1_0();
}
inline bool AddInIndicators::state_machine_1_0() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_0)
  return state_machine_1_0_;
}
inline void AddInIndicators::set_state_machine_1_0(bool value) {
  set_has_state_machine_1_0();
  state_machine_1_0_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_0)
}

// optional bool state_machine_1_1 = 3;
inline bool AddInIndicators::has_state_machine_1_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddInIndicators::set_has_state_machine_1_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddInIndicators::clear_has_state_machine_1_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddInIndicators::clear_state_machine_1_1() {
  state_machine_1_1_ = false;
  clear_has_state_machine_1_1();
}
inline bool AddInIndicators::state_machine_1_1() const {
  // @@protoc_insertion_point(field_get:abb.robot.AddInIndicators.state_machine_1_1)
  return state_machine_1_1_;
}
inline void AddInIndicators::set_state_machine_1_1(bool value) {
  set_has_state_machine_1_1();
  state_machine_1_1_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.AddInIndicators.state_machine_1_1)
}

// -------------------------------------------------------------------

// SystemIndicators

// optional .abb.robot.RobotIndicators robots = 1;
inline bool SystemIndicators::has_robots() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemIndicators::set_has_robots() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemIndicators::clear_has_robots() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemIndicators::clear_robots() {
  if (robots_ != NULL) robots_->Clear();
  clear_has_robots();
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::_internal_robots() const {
  return *robots_;
}
inline const ::abb::robot::RobotIndicators& SystemIndicators::robots() const {
  const ::abb::robot::RobotIndicators* p = robots_;
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.robots)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::RobotIndicators*>(
      &::abb::robot::_RobotIndicators_default_instance_);
}
inline ::abb::robot::RobotIndicators* SystemIndicators::release_robots() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.robots)
  clear_has_robots();
  ::abb::robot::RobotIndicators* temp = robots_;
  robots_ = NULL;
  return temp;
}
inline ::abb::robot::RobotIndicators* SystemIndicators::mutable_robots() {
  set_has_robots();
  if (robots_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::RobotIndicators>(GetArenaNoVirtual());
    robots_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.robots)
  return robots_;
}
inline void SystemIndicators::set_allocated_robots(::abb::robot::RobotIndicators* robots) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robots_;
  }
  if (robots) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robots = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robots, submessage_arena);
    }
    set_has_robots();
  } else {
    clear_has_robots();
  }
  robots_ = robots;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.robots)
}

// optional .abb.robot.OptionIndicators options = 2;
inline bool SystemIndicators::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemIndicators::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemIndicators::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemIndicators::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::_internal_options() const {
  return *options_;
}
inline const ::abb::robot::OptionIndicators& SystemIndicators::options() const {
  const ::abb::robot::OptionIndicators* p = options_;
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.options)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::OptionIndicators*>(
      &::abb::robot::_OptionIndicators_default_instance_);
}
inline ::abb::robot::OptionIndicators* SystemIndicators::release_options() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.options)
  clear_has_options();
  ::abb::robot::OptionIndicators* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::abb::robot::OptionIndicators* SystemIndicators::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::OptionIndicators>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.options)
  return options_;
}
inline void SystemIndicators::set_allocated_options(::abb::robot::OptionIndicators* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.options)
}

// optional .abb.robot.AddInIndicators addins = 3;
inline bool SystemIndicators::has_addins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemIndicators::set_has_addins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemIndicators::clear_has_addins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemIndicators::clear_addins() {
  if (addins_ != NULL) addins_->Clear();
  clear_has_addins();
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::_internal_addins() const {
  return *addins_;
}
inline const ::abb::robot::AddInIndicators& SystemIndicators::addins() const {
  const ::abb::robot::AddInIndicators* p = addins_;
  // @@protoc_insertion_point(field_get:abb.robot.SystemIndicators.addins)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::AddInIndicators*>(
      &::abb::robot::_AddInIndicators_default_instance_);
}
inline ::abb::robot::AddInIndicators* SystemIndicators::release_addins() {
  // @@protoc_insertion_point(field_release:abb.robot.SystemIndicators.addins)
  clear_has_addins();
  ::abb::robot::AddInIndicators* temp = addins_;
  addins_ = NULL;
  return temp;
}
inline ::abb::robot::AddInIndicators* SystemIndicators::mutable_addins() {
  set_has_addins();
  if (addins_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::AddInIndicators>(GetArenaNoVirtual());
    addins_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.SystemIndicators.addins)
  return addins_;
}
inline void SystemIndicators::set_allocated_addins(::abb::robot::AddInIndicators* addins) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete addins_;
  }
  if (addins) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      addins = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addins, submessage_arena);
    }
    set_has_addins();
  } else {
    clear_has_addins();
  }
  addins_ = addins;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.SystemIndicators.addins)
}

// -------------------------------------------------------------------

// Transmission

// optional string name = 1;
inline bool Transmission::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transmission::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transmission::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transmission::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Transmission::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.name)
  return name_.GetNoArena();
}
inline void Transmission::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.name)
}
#if LANG_CXX11
inline void Transmission::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Transmission.name)
}
#endif
inline void Transmission::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Transmission.name)
}
inline void Transmission::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Transmission.name)
}
inline ::std::string* Transmission::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Transmission.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transmission::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Transmission.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transmission::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Transmission.name)
}

// optional bool rotating_move = 2;
inline bool Transmission::has_rotating_move() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transmission::set_has_rotating_move() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transmission::clear_has_rotating_move() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transmission::clear_rotating_move() {
  rotating_move_ = false;
  clear_has_rotating_move();
}
inline bool Transmission::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.Transmission.rotating_move)
  return rotating_move_;
}
inline void Transmission::set_rotating_move(bool value) {
  set_has_rotating_move();
  rotating_move_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Transmission.rotating_move)
}

// -------------------------------------------------------------------

// Arm

// optional string name = 1;
inline bool Arm::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arm::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arm::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arm::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Arm::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.name)
  return name_.GetNoArena();
}
inline void Arm::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Arm.name)
}
#if LANG_CXX11
inline void Arm::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Arm.name)
}
#endif
inline void Arm::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Arm.name)
}
inline void Arm::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Arm.name)
}
inline ::std::string* Arm::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Arm.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Arm::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Arm.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Arm::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Arm.name)
}

// optional double lower_joint_bound = 2;
inline bool Arm::has_lower_joint_bound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arm::set_has_lower_joint_bound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arm::clear_has_lower_joint_bound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arm::clear_lower_joint_bound() {
  lower_joint_bound_ = 0;
  clear_has_lower_joint_bound();
}
inline double Arm::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.lower_joint_bound)
  return lower_joint_bound_;
}
inline void Arm::set_lower_joint_bound(double value) {
  set_has_lower_joint_bound();
  lower_joint_bound_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Arm.lower_joint_bound)
}

// optional double upper_joint_bound = 3;
inline bool Arm::has_upper_joint_bound() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Arm::set_has_upper_joint_bound() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Arm::clear_has_upper_joint_bound() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Arm::clear_upper_joint_bound() {
  upper_joint_bound_ = 0;
  clear_has_upper_joint_bound();
}
inline double Arm::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.Arm.upper_joint_bound)
  return upper_joint_bound_;
}
inline void Arm::set_upper_joint_bound(double value) {
  set_has_upper_joint_bound();
  upper_joint_bound_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Arm.upper_joint_bound)
}

// -------------------------------------------------------------------

// Joint

// optional string name = 1;
inline bool Joint::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Joint::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Joint::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Joint::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Joint::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.name)
  return name_.GetNoArena();
}
inline void Joint::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Joint.name)
}
#if LANG_CXX11
inline void Joint::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Joint.name)
}
#endif
inline void Joint::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Joint.name)
}
inline void Joint::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Joint.name)
}
inline ::std::string* Joint::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Joint::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Joint::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.name)
}

// optional int32 logical_axis = 2;
inline bool Joint::has_logical_axis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Joint::set_has_logical_axis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Joint::clear_has_logical_axis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Joint::clear_logical_axis() {
  logical_axis_ = 0;
  clear_has_logical_axis();
}
inline ::google::protobuf::int32 Joint::logical_axis() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.logical_axis)
  return logical_axis_;
}
inline void Joint::set_logical_axis(::google::protobuf::int32 value) {
  set_has_logical_axis();
  logical_axis_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Joint.logical_axis)
}

// optional int32 kinematic_axis_number = 3;
inline bool Joint::has_kinematic_axis_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Joint::set_has_kinematic_axis_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Joint::clear_has_kinematic_axis_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Joint::clear_kinematic_axis_number() {
  kinematic_axis_number_ = 0;
  clear_has_kinematic_axis_number();
}
inline ::google::protobuf::int32 Joint::kinematic_axis_number() const {
  // @@protoc_insertion_point(field_get:abb.robot.Joint.kinematic_axis_number)
  return kinematic_axis_number_;
}
inline void Joint::set_kinematic_axis_number(::google::protobuf::int32 value) {
  set_has_kinematic_axis_number();
  kinematic_axis_number_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.Joint.kinematic_axis_number)
}

// optional .abb.robot.Arm arm = 4;
inline bool Joint::has_arm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Joint::set_has_arm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Joint::clear_has_arm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Joint::clear_arm() {
  if (arm_ != NULL) arm_->Clear();
  clear_has_arm();
}
inline const ::abb::robot::Arm& Joint::_internal_arm() const {
  return *arm_;
}
inline const ::abb::robot::Arm& Joint::arm() const {
  const ::abb::robot::Arm* p = arm_;
  // @@protoc_insertion_point(field_get:abb.robot.Joint.arm)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Arm*>(
      &::abb::robot::_Arm_default_instance_);
}
inline ::abb::robot::Arm* Joint::release_arm() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.arm)
  clear_has_arm();
  ::abb::robot::Arm* temp = arm_;
  arm_ = NULL;
  return temp;
}
inline ::abb::robot::Arm* Joint::mutable_arm() {
  set_has_arm();
  if (arm_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Arm>(GetArenaNoVirtual());
    arm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.arm)
  return arm_;
}
inline void Joint::set_allocated_arm(::abb::robot::Arm* arm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete arm_;
  }
  if (arm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      arm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arm, submessage_arena);
    }
    set_has_arm();
  } else {
    clear_has_arm();
  }
  arm_ = arm;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.arm)
}

// optional .abb.robot.Transmission transmission = 5;
inline bool Joint::has_transmission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Joint::set_has_transmission() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Joint::clear_has_transmission() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Joint::clear_transmission() {
  if (transmission_ != NULL) transmission_->Clear();
  clear_has_transmission();
}
inline const ::abb::robot::Transmission& Joint::_internal_transmission() const {
  return *transmission_;
}
inline const ::abb::robot::Transmission& Joint::transmission() const {
  const ::abb::robot::Transmission* p = transmission_;
  // @@protoc_insertion_point(field_get:abb.robot.Joint.transmission)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Transmission*>(
      &::abb::robot::_Transmission_default_instance_);
}
inline ::abb::robot::Transmission* Joint::release_transmission() {
  // @@protoc_insertion_point(field_release:abb.robot.Joint.transmission)
  clear_has_transmission();
  ::abb::robot::Transmission* temp = transmission_;
  transmission_ = NULL;
  return temp;
}
inline ::abb::robot::Transmission* Joint::mutable_transmission() {
  set_has_transmission();
  if (transmission_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Transmission>(GetArenaNoVirtual());
    transmission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Joint.transmission)
  return transmission_;
}
inline void Joint::set_allocated_transmission(::abb::robot::Transmission* transmission) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transmission_;
  }
  if (transmission) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transmission = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transmission, submessage_arena);
    }
    set_has_transmission();
  } else {
    clear_has_transmission();
  }
  transmission_ = transmission;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Joint.transmission)
}

// -------------------------------------------------------------------

// StandardizedJoint

// optional string original_name = 1;
inline bool StandardizedJoint::has_original_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StandardizedJoint::set_has_original_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StandardizedJoint::clear_has_original_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StandardizedJoint::clear_original_name() {
  original_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_original_name();
}
inline const ::std::string& StandardizedJoint::original_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.original_name)
  return original_name_.GetNoArena();
}
inline void StandardizedJoint::set_original_name(const ::std::string& value) {
  set_has_original_name();
  original_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.original_name)
}
#if LANG_CXX11
inline void StandardizedJoint::set_original_name(::std::string&& value) {
  set_has_original_name();
  original_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.StandardizedJoint.original_name)
}
#endif
inline void StandardizedJoint::set_original_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_original_name();
  original_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.StandardizedJoint.original_name)
}
inline void StandardizedJoint::set_original_name(const char* value, size_t size) {
  set_has_original_name();
  original_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.StandardizedJoint.original_name)
}
inline ::std::string* StandardizedJoint::mutable_original_name() {
  set_has_original_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.original_name)
  return original_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StandardizedJoint::release_original_name() {
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.original_name)
  if (!has_original_name()) {
    return NULL;
  }
  clear_has_original_name();
  return original_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StandardizedJoint::set_allocated_original_name(::std::string* original_name) {
  if (original_name != NULL) {
    set_has_original_name();
  } else {
    clear_has_original_name();
  }
  original_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), original_name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.original_name)
}

// optional string standardized_name = 2;
inline bool StandardizedJoint::has_standardized_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StandardizedJoint::set_has_standardized_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StandardizedJoint::clear_has_standardized_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StandardizedJoint::clear_standardized_name() {
  standardized_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_standardized_name();
}
inline const ::std::string& StandardizedJoint::standardized_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.standardized_name)
  return standardized_name_.GetNoArena();
}
inline void StandardizedJoint::set_standardized_name(const ::std::string& value) {
  set_has_standardized_name();
  standardized_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.standardized_name)
}
#if LANG_CXX11
inline void StandardizedJoint::set_standardized_name(::std::string&& value) {
  set_has_standardized_name();
  standardized_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.StandardizedJoint.standardized_name)
}
#endif
inline void StandardizedJoint::set_standardized_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_standardized_name();
  standardized_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.StandardizedJoint.standardized_name)
}
inline void StandardizedJoint::set_standardized_name(const char* value, size_t size) {
  set_has_standardized_name();
  standardized_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.StandardizedJoint.standardized_name)
}
inline ::std::string* StandardizedJoint::mutable_standardized_name() {
  set_has_standardized_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.StandardizedJoint.standardized_name)
  return standardized_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StandardizedJoint::release_standardized_name() {
  // @@protoc_insertion_point(field_release:abb.robot.StandardizedJoint.standardized_name)
  if (!has_standardized_name()) {
    return NULL;
  }
  clear_has_standardized_name();
  return standardized_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StandardizedJoint::set_allocated_standardized_name(::std::string* standardized_name) {
  if (standardized_name != NULL) {
    set_has_standardized_name();
  } else {
    clear_has_standardized_name();
  }
  standardized_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), standardized_name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.StandardizedJoint.standardized_name)
}

// optional bool rotating_move = 3;
inline bool StandardizedJoint::has_rotating_move() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StandardizedJoint::set_has_rotating_move() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StandardizedJoint::clear_has_rotating_move() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StandardizedJoint::clear_rotating_move() {
  rotating_move_ = false;
  clear_has_rotating_move();
}
inline bool StandardizedJoint::rotating_move() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.rotating_move)
  return rotating_move_;
}
inline void StandardizedJoint::set_rotating_move(bool value) {
  set_has_rotating_move();
  rotating_move_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.rotating_move)
}

// optional double lower_joint_bound = 4;
inline bool StandardizedJoint::has_lower_joint_bound() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StandardizedJoint::set_has_lower_joint_bound() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StandardizedJoint::clear_has_lower_joint_bound() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StandardizedJoint::clear_lower_joint_bound() {
  lower_joint_bound_ = 0;
  clear_has_lower_joint_bound();
}
inline double StandardizedJoint::lower_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.lower_joint_bound)
  return lower_joint_bound_;
}
inline void StandardizedJoint::set_lower_joint_bound(double value) {
  set_has_lower_joint_bound();
  lower_joint_bound_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.lower_joint_bound)
}

// optional double upper_joint_bound = 5;
inline bool StandardizedJoint::has_upper_joint_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StandardizedJoint::set_has_upper_joint_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StandardizedJoint::clear_has_upper_joint_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StandardizedJoint::clear_upper_joint_bound() {
  upper_joint_bound_ = 0;
  clear_has_upper_joint_bound();
}
inline double StandardizedJoint::upper_joint_bound() const {
  // @@protoc_insertion_point(field_get:abb.robot.StandardizedJoint.upper_joint_bound)
  return upper_joint_bound_;
}
inline void StandardizedJoint::set_upper_joint_bound(double value) {
  set_has_upper_joint_bound();
  upper_joint_bound_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.StandardizedJoint.upper_joint_bound)
}

// -------------------------------------------------------------------

// Single

// optional string name = 1;
inline bool Single::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Single::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Single::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Single::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Single::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.name)
  return name_.GetNoArena();
}
inline void Single::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Single.name)
}
#if LANG_CXX11
inline void Single::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Single.name)
}
#endif
inline void Single::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Single.name)
}
inline void Single::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Single.name)
}
inline ::std::string* Single::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Single::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Single::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.name)
}

// optional string type = 2;
inline bool Single::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Single::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Single::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Single::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Single::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.type)
  return type_.GetNoArena();
}
inline void Single::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Single.type)
}
#if LANG_CXX11
inline void Single::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Single.type)
}
#endif
inline void Single::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Single.type)
}
inline void Single::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Single.type)
}
inline ::std::string* Single::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Single::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Single::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.type)
}

// optional .abb.robot.Joint joint = 3;
inline bool Single::has_joint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Single::set_has_joint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Single::clear_has_joint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Single::clear_joint() {
  if (joint_ != NULL) joint_->Clear();
  clear_has_joint();
}
inline const ::abb::robot::Joint& Single::_internal_joint() const {
  return *joint_;
}
inline const ::abb::robot::Joint& Single::joint() const {
  const ::abb::robot::Joint* p = joint_;
  // @@protoc_insertion_point(field_get:abb.robot.Single.joint)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Joint*>(
      &::abb::robot::_Joint_default_instance_);
}
inline ::abb::robot::Joint* Single::release_joint() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.joint)
  clear_has_joint();
  ::abb::robot::Joint* temp = joint_;
  joint_ = NULL;
  return temp;
}
inline ::abb::robot::Joint* Single::mutable_joint() {
  set_has_joint();
  if (joint_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Joint>(GetArenaNoVirtual());
    joint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.joint)
  return joint_;
}
inline void Single::set_allocated_joint(::abb::robot::Joint* joint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joint_;
  }
  if (joint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joint, submessage_arena);
    }
    set_has_joint();
  } else {
    clear_has_joint();
  }
  joint_ = joint;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.joint)
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Single::has_base_frame() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Single::set_has_base_frame() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Single::clear_has_base_frame() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Single::clear_base_frame() {
  if (base_frame_ != NULL) base_frame_->Clear();
  clear_has_base_frame();
}
inline const ::abb::robot::Pose& Single::_internal_base_frame() const {
  return *base_frame_;
}
inline const ::abb::robot::Pose& Single::base_frame() const {
  const ::abb::robot::Pose* p = base_frame_;
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Pose*>(
      &::abb::robot::_Pose_default_instance_);
}
inline ::abb::robot::Pose* Single::release_base_frame() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame)
  clear_has_base_frame();
  ::abb::robot::Pose* temp = base_frame_;
  base_frame_ = NULL;
  return temp;
}
inline ::abb::robot::Pose* Single::mutable_base_frame() {
  set_has_base_frame();
  if (base_frame_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArenaNoVirtual());
    base_frame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame)
  return base_frame_;
}
inline void Single::set_allocated_base_frame(::abb::robot::Pose* base_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_frame_;
  }
  if (base_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_frame, submessage_arena);
    }
    set_has_base_frame();
  } else {
    clear_has_base_frame();
  }
  base_frame_ = base_frame;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Single::has_base_frame_moved_by() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Single::set_has_base_frame_moved_by() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Single::clear_has_base_frame_moved_by() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Single::clear_base_frame_moved_by() {
  base_frame_moved_by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base_frame_moved_by();
}
inline const ::std::string& Single::base_frame_moved_by() const {
  // @@protoc_insertion_point(field_get:abb.robot.Single.base_frame_moved_by)
  return base_frame_moved_by_.GetNoArena();
}
inline void Single::set_base_frame_moved_by(const ::std::string& value) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Single.base_frame_moved_by)
}
#if LANG_CXX11
inline void Single::set_base_frame_moved_by(::std::string&& value) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Single.base_frame_moved_by)
}
#endif
inline void Single::set_base_frame_moved_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Single.base_frame_moved_by)
}
inline void Single::set_base_frame_moved_by(const char* value, size_t size) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Single.base_frame_moved_by)
}
inline ::std::string* Single::mutable_base_frame_moved_by() {
  set_has_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Single.base_frame_moved_by)
  return base_frame_moved_by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Single::release_base_frame_moved_by() {
  // @@protoc_insertion_point(field_release:abb.robot.Single.base_frame_moved_by)
  if (!has_base_frame_moved_by()) {
    return NULL;
  }
  clear_has_base_frame_moved_by();
  return base_frame_moved_by_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Single::set_allocated_base_frame_moved_by(::std::string* base_frame_moved_by) {
  if (base_frame_moved_by != NULL) {
    set_has_base_frame_moved_by();
  } else {
    clear_has_base_frame_moved_by();
  }
  base_frame_moved_by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_frame_moved_by);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Single.base_frame_moved_by)
}

// -------------------------------------------------------------------

// Robot

// optional string name = 1;
inline bool Robot::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Robot::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.name)
  return name_.GetNoArena();
}
inline void Robot::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Robot.name)
}
#if LANG_CXX11
inline void Robot::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Robot.name)
}
#endif
inline void Robot::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Robot.name)
}
inline void Robot::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Robot.name)
}
inline ::std::string* Robot::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Robot::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Robot::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.name)
}

// optional string type = 2;
inline bool Robot::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Robot::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.type)
  return type_.GetNoArena();
}
inline void Robot::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Robot.type)
}
#if LANG_CXX11
inline void Robot::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Robot.type)
}
#endif
inline void Robot::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Robot.type)
}
inline void Robot::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Robot.type)
}
inline ::std::string* Robot::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Robot::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Robot::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.type)
}

// repeated .abb.robot.Joint joints = 3;
inline int Robot::joints_size() const {
  return joints_.size();
}
inline void Robot::clear_joints() {
  joints_.Clear();
}
inline ::abb::robot::Joint* Robot::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.joints)
  return joints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >*
Robot::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.Robot.joints)
  return &joints_;
}
inline const ::abb::robot::Joint& Robot::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.joints)
  return joints_.Get(index);
}
inline ::abb::robot::Joint* Robot::add_joints() {
  // @@protoc_insertion_point(field_add:abb.robot.Robot.joints)
  return joints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::Joint >&
Robot::joints() const {
  // @@protoc_insertion_point(field_list:abb.robot.Robot.joints)
  return joints_;
}

// optional .abb.robot.Pose base_frame = 4;
inline bool Robot::has_base_frame() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_base_frame() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_base_frame() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_base_frame() {
  if (base_frame_ != NULL) base_frame_->Clear();
  clear_has_base_frame();
}
inline const ::abb::robot::Pose& Robot::_internal_base_frame() const {
  return *base_frame_;
}
inline const ::abb::robot::Pose& Robot::base_frame() const {
  const ::abb::robot::Pose* p = base_frame_;
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Pose*>(
      &::abb::robot::_Pose_default_instance_);
}
inline ::abb::robot::Pose* Robot::release_base_frame() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame)
  clear_has_base_frame();
  ::abb::robot::Pose* temp = base_frame_;
  base_frame_ = NULL;
  return temp;
}
inline ::abb::robot::Pose* Robot::mutable_base_frame() {
  set_has_base_frame();
  if (base_frame_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Pose>(GetArenaNoVirtual());
    base_frame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame)
  return base_frame_;
}
inline void Robot::set_allocated_base_frame(::abb::robot::Pose* base_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_frame_;
  }
  if (base_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_frame, submessage_arena);
    }
    set_has_base_frame();
  } else {
    clear_has_base_frame();
  }
  base_frame_ = base_frame;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame)
}

// optional string base_frame_moved_by = 5;
inline bool Robot::has_base_frame_moved_by() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_base_frame_moved_by() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_base_frame_moved_by() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_base_frame_moved_by() {
  base_frame_moved_by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base_frame_moved_by();
}
inline const ::std::string& Robot::base_frame_moved_by() const {
  // @@protoc_insertion_point(field_get:abb.robot.Robot.base_frame_moved_by)
  return base_frame_moved_by_.GetNoArena();
}
inline void Robot::set_base_frame_moved_by(const ::std::string& value) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.Robot.base_frame_moved_by)
}
#if LANG_CXX11
inline void Robot::set_base_frame_moved_by(::std::string&& value) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.Robot.base_frame_moved_by)
}
#endif
inline void Robot::set_base_frame_moved_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.Robot.base_frame_moved_by)
}
inline void Robot::set_base_frame_moved_by(const char* value, size_t size) {
  set_has_base_frame_moved_by();
  base_frame_moved_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.Robot.base_frame_moved_by)
}
inline ::std::string* Robot::mutable_base_frame_moved_by() {
  set_has_base_frame_moved_by();
  // @@protoc_insertion_point(field_mutable:abb.robot.Robot.base_frame_moved_by)
  return base_frame_moved_by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Robot::release_base_frame_moved_by() {
  // @@protoc_insertion_point(field_release:abb.robot.Robot.base_frame_moved_by)
  if (!has_base_frame_moved_by()) {
    return NULL;
  }
  clear_has_base_frame_moved_by();
  return base_frame_moved_by_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Robot::set_allocated_base_frame_moved_by(::std::string* base_frame_moved_by) {
  if (base_frame_moved_by != NULL) {
    set_has_base_frame_moved_by();
  } else {
    clear_has_base_frame_moved_by();
  }
  base_frame_moved_by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_frame_moved_by);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.Robot.base_frame_moved_by)
}

// -------------------------------------------------------------------

// MechanicalUnit

// optional string name = 1;
inline bool MechanicalUnit::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MechanicalUnit::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MechanicalUnit::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MechanicalUnit::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MechanicalUnit::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.name)
  return name_.GetNoArena();
}
inline void MechanicalUnit::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.name)
}
#if LANG_CXX11
inline void MechanicalUnit::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnit.name)
}
#endif
inline void MechanicalUnit::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnit.name)
}
inline void MechanicalUnit::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnit.name)
}
inline ::std::string* MechanicalUnit::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnit::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnit::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.name)
}

// optional .abb.robot.Robot robot = 2;
inline bool MechanicalUnit::has_robot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MechanicalUnit::set_has_robot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MechanicalUnit::clear_has_robot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MechanicalUnit::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::abb::robot::Robot& MechanicalUnit::_internal_robot() const {
  return *robot_;
}
inline const ::abb::robot::Robot& MechanicalUnit::robot() const {
  const ::abb::robot::Robot* p = robot_;
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::Robot*>(
      &::abb::robot::_Robot_default_instance_);
}
inline ::abb::robot::Robot* MechanicalUnit::release_robot() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.robot)
  clear_has_robot();
  ::abb::robot::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::abb::robot::Robot* MechanicalUnit::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::Robot>(GetArenaNoVirtual());
    robot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.robot)
  return robot_;
}
inline void MechanicalUnit::set_allocated_robot(::abb::robot::Robot* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.robot)
}

// repeated .abb.robot.Single singles = 3;
inline int MechanicalUnit::singles_size() const {
  return singles_.size();
}
inline void MechanicalUnit::clear_singles() {
  singles_.Clear();
}
inline ::abb::robot::Single* MechanicalUnit::mutable_singles(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.singles)
  return singles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >*
MechanicalUnit::mutable_singles() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.singles)
  return &singles_;
}
inline const ::abb::robot::Single& MechanicalUnit::singles(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.singles)
  return singles_.Get(index);
}
inline ::abb::robot::Single* MechanicalUnit::add_singles() {
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.singles)
  return singles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::Single >&
MechanicalUnit::singles() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.singles)
  return singles_;
}

// optional .abb.robot.MechanicalUnit.Type type = 4 [default = UNDEFINED];
inline bool MechanicalUnit::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MechanicalUnit::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MechanicalUnit::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MechanicalUnit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::abb::robot::MechanicalUnit_Type MechanicalUnit::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.type)
  return static_cast< ::abb::robot::MechanicalUnit_Type >(type_);
}
inline void MechanicalUnit::set_type(::abb::robot::MechanicalUnit_Type value) {
  assert(::abb::robot::MechanicalUnit_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.type)
}

// optional string task_name = 5;
inline bool MechanicalUnit::has_task_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MechanicalUnit::set_has_task_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MechanicalUnit::clear_has_task_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MechanicalUnit::clear_task_name() {
  task_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_name();
}
inline const ::std::string& MechanicalUnit::task_name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.task_name)
  return task_name_.GetNoArena();
}
inline void MechanicalUnit::set_task_name(const ::std::string& value) {
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.task_name)
}
#if LANG_CXX11
inline void MechanicalUnit::set_task_name(::std::string&& value) {
  set_has_task_name();
  task_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnit.task_name)
}
#endif
inline void MechanicalUnit::set_task_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnit.task_name)
}
inline void MechanicalUnit::set_task_name(const char* value, size_t size) {
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnit.task_name)
}
inline ::std::string* MechanicalUnit::mutable_task_name() {
  set_has_task_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.task_name)
  return task_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnit::release_task_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.task_name)
  if (!has_task_name()) {
    return NULL;
  }
  clear_has_task_name();
  return task_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnit::set_allocated_task_name(::std::string* task_name) {
  if (task_name != NULL) {
    set_has_task_name();
  } else {
    clear_has_task_name();
  }
  task_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.task_name)
}

// optional int32 axes = 6;
inline bool MechanicalUnit::has_axes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MechanicalUnit::set_has_axes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MechanicalUnit::clear_has_axes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MechanicalUnit::clear_axes() {
  axes_ = 0;
  clear_has_axes();
}
inline ::google::protobuf::int32 MechanicalUnit::axes() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes)
  return axes_;
}
inline void MechanicalUnit::set_axes(::google::protobuf::int32 value) {
  set_has_axes();
  axes_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes)
}

// optional int32 axes_total = 7;
inline bool MechanicalUnit::has_axes_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MechanicalUnit::set_has_axes_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MechanicalUnit::clear_has_axes_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MechanicalUnit::clear_axes_total() {
  axes_total_ = 0;
  clear_has_axes_total();
}
inline ::google::protobuf::int32 MechanicalUnit::axes_total() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.axes_total)
  return axes_total_;
}
inline void MechanicalUnit::set_axes_total(::google::protobuf::int32 value) {
  set_has_axes_total();
  axes_total_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.axes_total)
}

// optional string is_integrated_unit = 8;
inline bool MechanicalUnit::has_is_integrated_unit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MechanicalUnit::set_has_is_integrated_unit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MechanicalUnit::clear_has_is_integrated_unit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MechanicalUnit::clear_is_integrated_unit() {
  is_integrated_unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_is_integrated_unit();
}
inline const ::std::string& MechanicalUnit::is_integrated_unit() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.is_integrated_unit)
  return is_integrated_unit_.GetNoArena();
}
inline void MechanicalUnit::set_is_integrated_unit(const ::std::string& value) {
  set_has_is_integrated_unit();
  is_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.is_integrated_unit)
}
#if LANG_CXX11
inline void MechanicalUnit::set_is_integrated_unit(::std::string&& value) {
  set_has_is_integrated_unit();
  is_integrated_unit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnit.is_integrated_unit)
}
#endif
inline void MechanicalUnit::set_is_integrated_unit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_is_integrated_unit();
  is_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnit.is_integrated_unit)
}
inline void MechanicalUnit::set_is_integrated_unit(const char* value, size_t size) {
  set_has_is_integrated_unit();
  is_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnit.is_integrated_unit)
}
inline ::std::string* MechanicalUnit::mutable_is_integrated_unit() {
  set_has_is_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.is_integrated_unit)
  return is_integrated_unit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnit::release_is_integrated_unit() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.is_integrated_unit)
  if (!has_is_integrated_unit()) {
    return NULL;
  }
  clear_has_is_integrated_unit();
  return is_integrated_unit_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnit::set_allocated_is_integrated_unit(::std::string* is_integrated_unit) {
  if (is_integrated_unit != NULL) {
    set_has_is_integrated_unit();
  } else {
    clear_has_is_integrated_unit();
  }
  is_integrated_unit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), is_integrated_unit);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.is_integrated_unit)
}

// optional string has_integrated_unit = 9;
inline bool MechanicalUnit::has_has_integrated_unit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MechanicalUnit::set_has_has_integrated_unit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MechanicalUnit::clear_has_has_integrated_unit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MechanicalUnit::clear_has_integrated_unit() {
  has_integrated_unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_has_integrated_unit();
}
inline const ::std::string& MechanicalUnit::has_integrated_unit() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.has_integrated_unit)
  return has_integrated_unit_.GetNoArena();
}
inline void MechanicalUnit::set_has_integrated_unit(const ::std::string& value) {
  set_has_has_integrated_unit();
  has_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.has_integrated_unit)
}
#if LANG_CXX11
inline void MechanicalUnit::set_has_integrated_unit(::std::string&& value) {
  set_has_has_integrated_unit();
  has_integrated_unit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnit.has_integrated_unit)
}
#endif
inline void MechanicalUnit::set_has_integrated_unit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_has_integrated_unit();
  has_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnit.has_integrated_unit)
}
inline void MechanicalUnit::set_has_integrated_unit(const char* value, size_t size) {
  set_has_has_integrated_unit();
  has_integrated_unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnit.has_integrated_unit)
}
inline ::std::string* MechanicalUnit::mutable_has_integrated_unit() {
  set_has_has_integrated_unit();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.has_integrated_unit)
  return has_integrated_unit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnit::release_has_integrated_unit() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.has_integrated_unit)
  if (!has_has_integrated_unit()) {
    return NULL;
  }
  clear_has_has_integrated_unit();
  return has_integrated_unit_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnit::set_allocated_has_integrated_unit(::std::string* has_integrated_unit) {
  if (has_integrated_unit != NULL) {
    set_has_has_integrated_unit();
  } else {
    clear_has_has_integrated_unit();
  }
  has_integrated_unit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), has_integrated_unit);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.has_integrated_unit)
}

// optional string status = 10;
inline bool MechanicalUnit::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MechanicalUnit::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MechanicalUnit::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MechanicalUnit::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& MechanicalUnit::status() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.status)
  return status_.GetNoArena();
}
inline void MechanicalUnit::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.status)
}
#if LANG_CXX11
inline void MechanicalUnit::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnit.status)
}
#endif
inline void MechanicalUnit::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnit.status)
}
inline void MechanicalUnit::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnit.status)
}
inline ::std::string* MechanicalUnit::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnit::release_status() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnit.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnit::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnit.status)
}

// optional .abb.robot.MechanicalUnit.Mode mode = 11 [default = DEACTIVATED];
inline bool MechanicalUnit::has_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MechanicalUnit::set_has_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MechanicalUnit::clear_has_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MechanicalUnit::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::abb::robot::MechanicalUnit_Mode MechanicalUnit::mode() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.mode)
  return static_cast< ::abb::robot::MechanicalUnit_Mode >(mode_);
}
inline void MechanicalUnit::set_mode(::abb::robot::MechanicalUnit_Mode value) {
  assert(::abb::robot::MechanicalUnit_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnit.mode)
}

// repeated .abb.robot.StandardizedJoint standardized_joints = 12;
inline int MechanicalUnit::standardized_joints_size() const {
  return standardized_joints_.size();
}
inline void MechanicalUnit::clear_standardized_joints() {
  standardized_joints_.Clear();
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::mutable_standardized_joints(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnit.standardized_joints)
  return standardized_joints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >*
MechanicalUnit::mutable_standardized_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnit.standardized_joints)
  return &standardized_joints_;
}
inline const ::abb::robot::StandardizedJoint& MechanicalUnit::standardized_joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnit.standardized_joints)
  return standardized_joints_.Get(index);
}
inline ::abb::robot::StandardizedJoint* MechanicalUnit::add_standardized_joints() {
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnit.standardized_joints)
  return standardized_joints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::StandardizedJoint >&
MechanicalUnit::standardized_joints() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnit.standardized_joints)
  return standardized_joints_;
}

// -------------------------------------------------------------------

// MechanicalUnitGroup

// optional string name = 1;
inline bool MechanicalUnitGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MechanicalUnitGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MechanicalUnitGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MechanicalUnitGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MechanicalUnitGroup::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.name)
  return name_.GetNoArena();
}
inline void MechanicalUnitGroup::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.MechanicalUnitGroup.name)
}
#if LANG_CXX11
inline void MechanicalUnitGroup::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.MechanicalUnitGroup.name)
}
#endif
inline void MechanicalUnitGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.MechanicalUnitGroup.name)
}
inline void MechanicalUnitGroup::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.MechanicalUnitGroup.name)
}
inline ::std::string* MechanicalUnitGroup::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MechanicalUnitGroup::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MechanicalUnitGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.name)
}

// optional .abb.robot.MechanicalUnit robot = 2;
inline bool MechanicalUnitGroup::has_robot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MechanicalUnitGroup::set_has_robot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MechanicalUnitGroup::clear_has_robot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MechanicalUnitGroup::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::_internal_robot() const {
  return *robot_;
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::robot() const {
  const ::abb::robot::MechanicalUnit* p = robot_;
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::robot::MechanicalUnit*>(
      &::abb::robot::_MechanicalUnit_default_instance_);
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::release_robot() {
  // @@protoc_insertion_point(field_release:abb.robot.MechanicalUnitGroup.robot)
  clear_has_robot();
  ::abb::robot::MechanicalUnit* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    auto* p = CreateMaybeMessage<::abb::robot::MechanicalUnit>(GetArenaNoVirtual());
    robot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.robot)
  return robot_;
}
inline void MechanicalUnitGroup::set_allocated_robot(::abb::robot::MechanicalUnit* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:abb.robot.MechanicalUnitGroup.robot)
}

// repeated .abb.robot.MechanicalUnit mechanical_units = 3;
inline int MechanicalUnitGroup::mechanical_units_size() const {
  return mechanical_units_.size();
}
inline void MechanicalUnitGroup::clear_mechanical_units() {
  mechanical_units_.Clear();
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::mutable_mechanical_units(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.MechanicalUnitGroup.mechanical_units)
  return mechanical_units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >*
MechanicalUnitGroup::mutable_mechanical_units() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  return &mechanical_units_;
}
inline const ::abb::robot::MechanicalUnit& MechanicalUnitGroup::mechanical_units(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.MechanicalUnitGroup.mechanical_units)
  return mechanical_units_.Get(index);
}
inline ::abb::robot::MechanicalUnit* MechanicalUnitGroup::add_mechanical_units() {
  // @@protoc_insertion_point(field_add:abb.robot.MechanicalUnitGroup.mechanical_units)
  return mechanical_units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::MechanicalUnit >&
MechanicalUnitGroup::mechanical_units() const {
  // @@protoc_insertion_point(field_list:abb.robot.MechanicalUnitGroup.mechanical_units)
  return mechanical_units_;
}

// -------------------------------------------------------------------

// RAPIDModule

// optional string name = 1;
inline bool RAPIDModule::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAPIDModule::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAPIDModule::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAPIDModule::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RAPIDModule::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.name)
  return name_.GetNoArena();
}
inline void RAPIDModule::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.name)
}
#if LANG_CXX11
inline void RAPIDModule::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.RAPIDModule.name)
}
#endif
inline void RAPIDModule::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.RAPIDModule.name)
}
inline void RAPIDModule::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.RAPIDModule.name)
}
inline ::std::string* RAPIDModule::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RAPIDModule::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RAPIDModule::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.name)
}

// optional string type = 2;
inline bool RAPIDModule::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RAPIDModule::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RAPIDModule::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RAPIDModule::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& RAPIDModule::type() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDModule.type)
  return type_.GetNoArena();
}
inline void RAPIDModule::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDModule.type)
}
#if LANG_CXX11
inline void RAPIDModule::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.RAPIDModule.type)
}
#endif
inline void RAPIDModule::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.RAPIDModule.type)
}
inline void RAPIDModule::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.RAPIDModule.type)
}
inline ::std::string* RAPIDModule::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDModule.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RAPIDModule::release_type() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDModule.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RAPIDModule::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDModule.type)
}

// -------------------------------------------------------------------

// RAPIDTask

// optional string name = 1;
inline bool RAPIDTask::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAPIDTask::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAPIDTask::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAPIDTask::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RAPIDTask::name() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.name)
  return name_.GetNoArena();
}
inline void RAPIDTask::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.name)
}
#if LANG_CXX11
inline void RAPIDTask::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:abb.robot.RAPIDTask.name)
}
#endif
inline void RAPIDTask::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:abb.robot.RAPIDTask.name)
}
inline void RAPIDTask::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:abb.robot.RAPIDTask.name)
}
inline ::std::string* RAPIDTask::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RAPIDTask::release_name() {
  // @@protoc_insertion_point(field_release:abb.robot.RAPIDTask.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RAPIDTask::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:abb.robot.RAPIDTask.name)
}

// optional bool is_motion_task = 2;
inline bool RAPIDTask::has_is_motion_task() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RAPIDTask::set_has_is_motion_task() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RAPIDTask::clear_has_is_motion_task() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RAPIDTask::clear_is_motion_task() {
  is_motion_task_ = false;
  clear_has_is_motion_task();
}
inline bool RAPIDTask::is_motion_task() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_motion_task)
  return is_motion_task_;
}
inline void RAPIDTask::set_is_motion_task(bool value) {
  set_has_is_motion_task();
  is_motion_task_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_motion_task)
}

// optional bool is_active = 3;
inline bool RAPIDTask::has_is_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RAPIDTask::set_has_is_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RAPIDTask::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RAPIDTask::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool RAPIDTask::is_active() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.is_active)
  return is_active_;
}
inline void RAPIDTask::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.is_active)
}

// optional .abb.robot.RAPIDTask.ExecutionState execution_state = 4 [default = UNKNOWN];
inline bool RAPIDTask::has_execution_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RAPIDTask::set_has_execution_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RAPIDTask::clear_has_execution_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RAPIDTask::clear_execution_state() {
  execution_state_ = 1;
  clear_has_execution_state();
}
inline ::abb::robot::RAPIDTask_ExecutionState RAPIDTask::execution_state() const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.execution_state)
  return static_cast< ::abb::robot::RAPIDTask_ExecutionState >(execution_state_);
}
inline void RAPIDTask::set_execution_state(::abb::robot::RAPIDTask_ExecutionState value) {
  assert(::abb::robot::RAPIDTask_ExecutionState_IsValid(value));
  set_has_execution_state();
  execution_state_ = value;
  // @@protoc_insertion_point(field_set:abb.robot.RAPIDTask.execution_state)
}

// repeated .abb.robot.RAPIDModule modules = 5;
inline int RAPIDTask::modules_size() const {
  return modules_.size();
}
inline void RAPIDTask::clear_modules() {
  modules_.Clear();
}
inline ::abb::robot::RAPIDModule* RAPIDTask::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:abb.robot.RAPIDTask.modules)
  return modules_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >*
RAPIDTask::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:abb.robot.RAPIDTask.modules)
  return &modules_;
}
inline const ::abb::robot::RAPIDModule& RAPIDTask::modules(int index) const {
  // @@protoc_insertion_point(field_get:abb.robot.RAPIDTask.modules)
  return modules_.Get(index);
}
inline ::abb::robot::RAPIDModule* RAPIDTask::add_modules() {
  // @@protoc_insertion_point(field_add:abb.robot.RAPIDTask.modules)
  return modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::abb::robot::RAPIDModule >&
RAPIDTask::modules() const {
  // @@protoc_insertion_point(field_list:abb.robot.RAPIDTask.modules)
  return modules_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot
}  // namespace abb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::abb::robot::MechanicalUnit_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::MechanicalUnit_Type>() {
  return ::abb::robot::MechanicalUnit_Type_descriptor();
}
template <> struct is_proto_enum< ::abb::robot::MechanicalUnit_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::MechanicalUnit_Mode>() {
  return ::abb::robot::MechanicalUnit_Mode_descriptor();
}
template <> struct is_proto_enum< ::abb::robot::RAPIDTask_ExecutionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::robot::RAPIDTask_ExecutionState>() {
  return ::abb::robot::RAPIDTask_ExecutionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_robot_5fcontroller_5fdescription_2eproto
